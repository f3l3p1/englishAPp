"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const core_1 = require("@angular-devkit/core");
const npm_1 = require("./npm");
const stripJsonComments = require("strip-json-comments");
const lodash_1 = require("lodash");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
/**
 * Serialize JSON.
 */
function serializeJson(json) {
    return `${JSON.stringify(json, null, 2)}\n`;
}
exports.serializeJson = serializeJson;
function parseJsonAtPath(tree, path) {
    const buffer = tree.read(path);
    if (buffer === null) {
        throw new schematics_1.SchematicsException(`Could not JSON at ${path}`);
    }
    const content = buffer.toString();
    const json = core_1.parseJsonAst(content, core_1.JsonParseMode.Strict);
    if (json.kind != 'object') {
        throw new schematics_1.SchematicsException('Invalid json. Was expecting an object');
    }
    return json.value;
}
exports.parseJsonAtPath = parseJsonAtPath;
/**
 * Read a JSON file.
 */
function readJsonInTree(host, path) {
    if (!host.exists(path)) {
        throw new Error(`Cannot find ${path}`);
    }
    const contents = stripJsonComments(host.read(path).toString('utf-8'));
    try {
        return JSON.parse(contents);
    }
    catch (e) {
        throw new Error(`Cannot parse ${path}: ${e.message}`);
    }
}
exports.readJsonInTree = readJsonInTree;
/**
 * This method is specifically for updating JSON in a Tree
 * @param path Path of JSON file in the Tree
 * @param callback Manipulation of the JSON data
 * @returns A rule which updates a JSON file file in a Tree
 */
function updateJsonInTree(path, callback) {
    return (host, context) => {
        if (!host.exists(path)) {
            host.create(path, serializeJson(callback({}, context)));
            return host;
        }
        host.overwrite(path, serializeJson(callback(readJsonInTree(host, path), context)));
        return host;
    };
}
exports.updateJsonInTree = updateJsonInTree;
/**
 * Combine two JSON objects.
 * Recursively merges own and inherited enumerable string keyed properties of source objects into the destination object.
 */
function mergeJson(jsonA, JsonB) {
    return lodash_1.mergeWith(jsonA, JsonB, mergeCustomizer);
}
exports.mergeJson = mergeJson;
/**
 * Handle Arrays by concatenating source values to the destination.
 */
function mergeCustomizer(objValue, srcValue) {
    if (lodash_1.isArray(objValue)) {
        return objValue.concat(srcValue);
    }
}
exports.mergeCustomizer = mergeCustomizer;
/**
 * Combine two JSON objects and update the tree.
 */
function mergeJsonTree(tree, path, jsonA, JsonB) {
    const jsonString = JSON.stringify(mergeJson(jsonA, JsonB), null, 2);
    tree.overwrite(path, jsonString);
    return tree;
}
exports.mergeJsonTree = mergeJsonTree;
/**
 * Update the package.json with a mergeObject that defines the differences.
 */
function mergePackageJson(tree, mergeObject, path = npm_1.PkgJson.Path) {
    return mergeJsonTree(tree, path, parseJsonAtPath(tree, path), mergeObject);
}
exports.mergePackageJson = mergePackageJson;
/**
 * Add a package json dependency (dev, devDep) setting version as the from npm.
 */
function addPackageJsonDep(tree, type, deps, path = npm_1.PkgJson.Path, context) {
    return rxjs_1.of(...deps).pipe(operators_1.concatMap((pkg) => (pkg.version ? rxjs_1.of(pkg) : npm_1.getLatestNodeVersion(pkg.name))), operators_1.map((packageFromRegistry) => {
        const { name, version } = packageFromRegistry;
        if (context) {
            context.logger.debug(`Adding ${name}:${version} to ${type}`);
        }
        return mergePackageJson(tree, { [type]: { [name]: version } }, path);
    }));
}
exports.addPackageJsonDep = addPackageJsonDep;
//# sourceMappingURL=json.js.map