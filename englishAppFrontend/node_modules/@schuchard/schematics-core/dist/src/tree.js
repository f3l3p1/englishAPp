"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const path = require("path");
const ts = require("typescript");
const fs = require("fs");
/**
 * Don't add file at `path` if it already exists.
 */
function filterExistingPath(tree, filePath, context) {
    return tree.exists(filePath)
        ? schematics_1.filter((schematicPath) => {
            const filename = path.basename(filePath);
            const fileExists = schematicPath.endsWith(filename);
            if (fileExists && context) {
                context.logger.warn(`Not adding ${filename}. File exists at ${filePath}`);
            }
            return !fileExists;
        })
        : schematics_1.noop();
}
exports.filterExistingPath = filterExistingPath;
/**
 * Return the matching nodes based on the predicate or all the nodes.
 */
function findSourceNodes(sourceFile, filter, debug = false) {
    const nodes = [sourceFile];
    let result = [];
    while (nodes.length > 0) {
        const node = nodes.shift();
        if (node) {
            result.push(node);
            if (debug) {
                console.log(`kind:${node.kind}, syntaxKind: ${ts.SyntaxKind[node.kind]}`);
            }
            if (filter(node)) {
                result = [node];
                break;
            }
            if (node.getChildCount(sourceFile) >= 0) {
                nodes.unshift(...node.getChildren());
            }
        }
    }
    return result;
}
exports.findSourceNodes = findSourceNodes;
/**
 * Update file, creating it if doesn't exist
 */
function createOrUpdate(host, path, content) {
    if (host.exists(path)) {
        host.overwrite(path, content);
    }
    else {
        host.create(path, content);
    }
}
exports.createOrUpdate = createOrUpdate;
/**
 * Get a list of all file paths
 */
function getAllFilePaths({ nodePath = '.', excludePath = (nodePath) => ['node_modules', 'dist', 'e2e'].some((dir) => nodePath.startsWith(dir)), }) {
    try {
        if (excludePath(nodePath)) {
            return [];
        }
        return fs.readdirSync(nodePath).reduce((acc, val) => {
            const joinedPath = path.join(nodePath, val);
            return acc.concat(fs.statSync(joinedPath).isDirectory()
                ? [...getAllFilePaths({ nodePath: joinedPath })]
                : joinedPath);
        }, []);
    }
    catch (err) {
        if (err.code === 'ENOTDIR') {
            return [];
        }
        return [];
    }
}
exports.getAllFilePaths = getAllFilePaths;
//# sourceMappingURL=tree.js.map