{"ast":null,"code":"import _defineProperty from \"/Users/user/Documents/Workspace/englishApp/englishAppFrontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport 'firebase/compat/auth';\nimport { isPlatformServer } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, NgModule } from '@angular/core';\nimport * as i1 from '@angular/fire';\nimport { keepUnstableUntilFirst, VERSION } from '@angular/fire';\nimport * as i2 from '@angular/fire/app-check';\nimport { ɵcacheInstance as _cacheInstance, ɵfirebaseAppFactory as _firebaseAppFactory, ɵlazySDKProxy as _lazySDKProxy, FIREBASE_OPTIONS, FIREBASE_APP_NAME, ɵapplyMixins as _applyMixins } from '@angular/fire/compat';\nimport { Subject, of, Observable, from, merge } from 'rxjs';\nimport { observeOn, switchMap, map, shareReplay, first, switchMapTo, subscribeOn, filter } from 'rxjs/operators';\nimport firebase from 'firebase/compat/app';\n\n// DO NOT MODIFY, this file is autogenerated by tools/build.ts\n// Export a null object with the same keys as firebase/compat/auth, so Proxy can work with proxy-polyfill in Internet Explorer\nconst proxyPolyfillCompat = {\n  name: null,\n  config: null,\n  emulatorConfig: null,\n  app: null,\n  applyActionCode: null,\n  checkActionCode: null,\n  confirmPasswordReset: null,\n  createUserWithEmailAndPassword: null,\n  currentUser: null,\n  fetchSignInMethodsForEmail: null,\n  isSignInWithEmailLink: null,\n  getRedirectResult: null,\n  languageCode: null,\n  settings: null,\n  onAuthStateChanged: null,\n  onIdTokenChanged: null,\n  sendSignInLinkToEmail: null,\n  sendPasswordResetEmail: null,\n  setPersistence: null,\n  signInAndRetrieveDataWithCredential: null,\n  signInAnonymously: null,\n  signInWithCredential: null,\n  signInWithCustomToken: null,\n  signInWithEmailAndPassword: null,\n  signInWithPhoneNumber: null,\n  signInWithEmailLink: null,\n  signInWithPopup: null,\n  signInWithRedirect: null,\n  signOut: null,\n  tenantId: null,\n  updateCurrentUser: null,\n  useDeviceLanguage: null,\n  useEmulator: null,\n  verifyPasswordResetCode: null\n};\nconst USE_EMULATOR = /*#__PURE__*/new InjectionToken('angularfire2.auth.use-emulator');\nconst SETTINGS = /*#__PURE__*/new InjectionToken('angularfire2.auth.settings');\nconst TENANT_ID = /*#__PURE__*/new InjectionToken('angularfire2.auth.tenant-id');\nconst LANGUAGE_CODE = /*#__PURE__*/new InjectionToken('angularfire2.auth.langugage-code');\nconst USE_DEVICE_LANGUAGE = /*#__PURE__*/new InjectionToken('angularfire2.auth.use-device-language');\nconst PERSISTENCE = /*#__PURE__*/new InjectionToken('angularfire.auth.persistence');\nconst ɵauthFactory = (app, zone, useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence) => _cacheInstance(`${app.name}.auth`, 'AngularFireAuth', app.name, () => {\n  const auth = zone.runOutsideAngular(() => app.auth());\n  if (useEmulator) {\n    auth.useEmulator(...useEmulator);\n  }\n  if (tenantId) {\n    auth.tenantId = tenantId;\n  }\n  auth.languageCode = languageCode;\n  if (useDeviceLanguage) {\n    auth.useDeviceLanguage();\n  }\n  if (settings) {\n    for (const [k, v] of Object.entries(settings)) {\n      auth.settings[k] = v;\n    }\n  }\n  if (persistence) {\n    auth.setPersistence(persistence);\n  }\n  return auth;\n}, [useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence]);\nlet AngularFireAuth = /*#__PURE__*/(() => {\n  var _AngularFireAuth;\n  class AngularFireAuth {\n    constructor(options, name,\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    platformId, zone, schedulers, useEmulator,\n    // can't use the tuple here\n    settings,\n    // can't use firebase.auth.AuthSettings here\n    tenantId, languageCode, useDeviceLanguage, persistence, _appCheckInstances) {\n      /**\n       * Observable of authentication state; as of Firebase 4.0 this is only triggered via sign-in/out\n       */\n      _defineProperty(this, \"authState\", void 0);\n      /**\n       * Observable of the currently signed-in user's JWT token used to identify the user to a Firebase service (or null).\n       */\n      _defineProperty(this, \"idToken\", void 0);\n      /**\n       * Observable of the currently signed-in user (or null).\n       */\n      _defineProperty(this, \"user\", void 0);\n      /**\n       * Observable of the currently signed-in user's IdTokenResult object which contains the ID token JWT string and other\n       * helper properties for getting different data associated with the token as well as all the decoded payload claims\n       * (or null).\n       */\n      _defineProperty(this, \"idTokenResult\", void 0);\n      /**\n       * Observable of the currently signed-in user's credential, or null\n       */\n      _defineProperty(this, \"credential\", void 0);\n      const logins = new Subject();\n      const auth = of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(() => zone.runOutsideAngular(() => import('firebase/compat/auth'))), map(() => _firebaseAppFactory(options, zone, name)), map(app => ɵauthFactory(app, zone, useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence)), shareReplay({\n        bufferSize: 1,\n        refCount: false\n      }));\n      if (isPlatformServer(platformId)) {\n        this.authState = this.user = this.idToken = this.idTokenResult = this.credential = of(null);\n      } else {\n        // HACK, as we're exporting auth.Auth, rather than auth, developers importing firebase.auth\n        //       (e.g, `import { auth } from 'firebase/compat/app'`) are getting an undefined auth object unexpectedly\n        //       as we're completely lazy. Let's eagerly load the Auth SDK here.\n        //       There could potentially be race conditions still... but this greatly decreases the odds while\n        //       we reevaluate the API.\n        auth.pipe(first()).subscribe();\n        const redirectResult = auth.pipe(switchMap(auth => auth.getRedirectResult().then(it => it, () => null)), keepUnstableUntilFirst, shareReplay({\n          bufferSize: 1,\n          refCount: false\n        }));\n        const authStateChanged = auth.pipe(switchMap(auth => new Observable(sub => ({\n          unsubscribe: zone.runOutsideAngular(() => auth.onAuthStateChanged(next => sub.next(next), err => sub.error(err), () => sub.complete()))\n        }))));\n        const idTokenChanged = auth.pipe(switchMap(auth => new Observable(sub => ({\n          unsubscribe: zone.runOutsideAngular(() => auth.onIdTokenChanged(next => sub.next(next), err => sub.error(err), () => sub.complete()))\n        }))));\n        this.authState = redirectResult.pipe(switchMapTo(authStateChanged), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n        this.user = redirectResult.pipe(switchMapTo(idTokenChanged), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n        this.idToken = this.user.pipe(switchMap(user => user ? from(user.getIdToken()) : of(null)));\n        this.idTokenResult = this.user.pipe(switchMap(user => user ? from(user.getIdTokenResult()) : of(null)));\n        this.credential = merge(redirectResult, logins,\n        // pipe in null authState to make credential zipable, just a weird devexp if\n        // authState and user go null to still have a credential\n        this.authState.pipe(filter(it => !it))).pipe(\n        // handle the { user: { } } when a user is already logged in, rather have null\n        // TODO handle the type corcersion better\n        map(credential => credential !== null && credential !== void 0 && credential.user ? credential : null), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n      }\n      return _lazySDKProxy(this, auth, zone, {\n        spy: {\n          apply: (name, _, val) => {\n            // If they call a signIn or createUser function listen into the promise\n            // this will give us the user credential, push onto the logins Subject\n            // to be consumed in .credential\n            if (name.startsWith('signIn') || name.startsWith('createUser')) {\n              // TODO fix the types, the trouble is UserCredential has everything optional\n              val.then(user => logins.next(user));\n            }\n          }\n        }\n      });\n    }\n  }\n  _AngularFireAuth = AngularFireAuth;\n  _defineProperty(AngularFireAuth, \"\\u0275fac\", function _AngularFireAuth_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _AngularFireAuth)(i0.ɵɵinject(FIREBASE_OPTIONS), i0.ɵɵinject(FIREBASE_APP_NAME, 8), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.ɵAngularFireSchedulers), i0.ɵɵinject(USE_EMULATOR, 8), i0.ɵɵinject(SETTINGS, 8), i0.ɵɵinject(TENANT_ID, 8), i0.ɵɵinject(LANGUAGE_CODE, 8), i0.ɵɵinject(USE_DEVICE_LANGUAGE, 8), i0.ɵɵinject(PERSISTENCE, 8), i0.ɵɵinject(i2.AppCheckInstances, 8));\n  });\n  _defineProperty(AngularFireAuth, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _AngularFireAuth,\n    factory: _AngularFireAuth.ɵfac,\n    providedIn: 'any'\n  }));\n  return AngularFireAuth;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*#__PURE__*/_applyMixins(AngularFireAuth, [proxyPolyfillCompat]);\nlet AngularFireAuthModule = /*#__PURE__*/(() => {\n  var _AngularFireAuthModule;\n  class AngularFireAuthModule {\n    constructor() {\n      firebase.registerVersion('angularfire', VERSION.full, 'auth-compat');\n    }\n  }\n  _AngularFireAuthModule = AngularFireAuthModule;\n  _defineProperty(AngularFireAuthModule, \"\\u0275fac\", function _AngularFireAuthModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _AngularFireAuthModule)();\n  });\n  _defineProperty(AngularFireAuthModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _AngularFireAuthModule\n  }));\n  _defineProperty(AngularFireAuthModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [AngularFireAuth]\n  }));\n  return AngularFireAuthModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngularFireAuth, AngularFireAuthModule, LANGUAGE_CODE, PERSISTENCE, SETTINGS, TENANT_ID, USE_DEVICE_LANGUAGE, USE_EMULATOR, ɵauthFactory };","map":{"version":3,"names":["isPlatformServer","i0","InjectionToken","PLATFORM_ID","Injectable","Inject","Optional","NgModule","i1","keepUnstableUntilFirst","VERSION","i2","ɵcacheInstance","_cacheInstance","ɵfirebaseAppFactory","_firebaseAppFactory","ɵlazySDKProxy","_lazySDKProxy","FIREBASE_OPTIONS","FIREBASE_APP_NAME","ɵapplyMixins","_applyMixins","Subject","of","Observable","from","merge","observeOn","switchMap","map","shareReplay","first","switchMapTo","subscribeOn","filter","firebase","proxyPolyfillCompat","name","config","emulatorConfig","app","applyActionCode","checkActionCode","confirmPasswordReset","createUserWithEmailAndPassword","currentUser","fetchSignInMethodsForEmail","isSignInWithEmailLink","getRedirectResult","languageCode","settings","onAuthStateChanged","onIdTokenChanged","sendSignInLinkToEmail","sendPasswordResetEmail","setPersistence","signInAndRetrieveDataWithCredential","signInAnonymously","signInWithCredential","signInWithCustomToken","signInWithEmailAndPassword","signInWithPhoneNumber","signInWithEmailLink","signInWithPopup","signInWithRedirect","signOut","tenantId","updateCurrentUser","useDeviceLanguage","useEmulator","verifyPasswordResetCode","USE_EMULATOR","SETTINGS","TENANT_ID","LANGUAGE_CODE","USE_DEVICE_LANGUAGE","PERSISTENCE","ɵauthFactory","zone","persistence","auth","runOutsideAngular","k","v","Object","entries","AngularFireAuth","_AngularFireAuth","constructor","options","platformId","schedulers","_appCheckInstances","_defineProperty","logins","undefined","pipe","outsideAngular","bufferSize","refCount","authState","user","idToken","idTokenResult","credential","subscribe","redirectResult","then","it","authStateChanged","sub","unsubscribe","next","err","error","complete","idTokenChanged","insideAngular","getIdToken","getIdTokenResult","spy","apply","_","val","startsWith","_AngularFireAuth_Factory","__ngFactoryType__","ɵɵinject","NgZone","ɵAngularFireSchedulers","AppCheckInstances","ɵɵdefineInjectable","token","factory","ɵfac","providedIn","ngDevMode","AngularFireAuthModule","_AngularFireAuthModule","registerVersion","full","_AngularFireAuthModule_Factory","ɵɵdefineNgModule","type","ɵɵdefineInjector","providers"],"sources":["/Users/user/Documents/Workspace/englishApp/englishAppFrontend/node_modules/@angular/fire/fesm2022/angular-fire-compat-auth.mjs"],"sourcesContent":["import 'firebase/compat/auth';\nimport { isPlatformServer } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, NgModule } from '@angular/core';\nimport * as i1 from '@angular/fire';\nimport { keepUnstableUntilFirst, VERSION } from '@angular/fire';\nimport * as i2 from '@angular/fire/app-check';\nimport { ɵcacheInstance as _cacheInstance, ɵfirebaseAppFactory as _firebaseAppFactory, ɵlazySDKProxy as _lazySDKProxy, FIREBASE_OPTIONS, FIREBASE_APP_NAME, ɵapplyMixins as _applyMixins } from '@angular/fire/compat';\nimport { Subject, of, Observable, from, merge } from 'rxjs';\nimport { observeOn, switchMap, map, shareReplay, first, switchMapTo, subscribeOn, filter } from 'rxjs/operators';\nimport firebase from 'firebase/compat/app';\n\n// DO NOT MODIFY, this file is autogenerated by tools/build.ts\n// Export a null object with the same keys as firebase/compat/auth, so Proxy can work with proxy-polyfill in Internet Explorer\nconst proxyPolyfillCompat = {\n    name: null,\n    config: null,\n    emulatorConfig: null,\n    app: null,\n    applyActionCode: null,\n    checkActionCode: null,\n    confirmPasswordReset: null,\n    createUserWithEmailAndPassword: null,\n    currentUser: null,\n    fetchSignInMethodsForEmail: null,\n    isSignInWithEmailLink: null,\n    getRedirectResult: null,\n    languageCode: null,\n    settings: null,\n    onAuthStateChanged: null,\n    onIdTokenChanged: null,\n    sendSignInLinkToEmail: null,\n    sendPasswordResetEmail: null,\n    setPersistence: null,\n    signInAndRetrieveDataWithCredential: null,\n    signInAnonymously: null,\n    signInWithCredential: null,\n    signInWithCustomToken: null,\n    signInWithEmailAndPassword: null,\n    signInWithPhoneNumber: null,\n    signInWithEmailLink: null,\n    signInWithPopup: null,\n    signInWithRedirect: null,\n    signOut: null,\n    tenantId: null,\n    updateCurrentUser: null,\n    useDeviceLanguage: null,\n    useEmulator: null,\n    verifyPasswordResetCode: null,\n};\n\nconst USE_EMULATOR = new InjectionToken('angularfire2.auth.use-emulator');\nconst SETTINGS = new InjectionToken('angularfire2.auth.settings');\nconst TENANT_ID = new InjectionToken('angularfire2.auth.tenant-id');\nconst LANGUAGE_CODE = new InjectionToken('angularfire2.auth.langugage-code');\nconst USE_DEVICE_LANGUAGE = new InjectionToken('angularfire2.auth.use-device-language');\nconst PERSISTENCE = new InjectionToken('angularfire.auth.persistence');\nconst ɵauthFactory = (app, zone, useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence) => _cacheInstance(`${app.name}.auth`, 'AngularFireAuth', app.name, () => {\n    const auth = zone.runOutsideAngular(() => app.auth());\n    if (useEmulator) {\n        auth.useEmulator(...useEmulator);\n    }\n    if (tenantId) {\n        auth.tenantId = tenantId;\n    }\n    auth.languageCode = languageCode;\n    if (useDeviceLanguage) {\n        auth.useDeviceLanguage();\n    }\n    if (settings) {\n        for (const [k, v] of Object.entries(settings)) {\n            auth.settings[k] = v;\n        }\n    }\n    if (persistence) {\n        auth.setPersistence(persistence);\n    }\n    return auth;\n}, [useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence]);\nclass AngularFireAuth {\n    /**\n     * Observable of authentication state; as of Firebase 4.0 this is only triggered via sign-in/out\n     */\n    authState;\n    /**\n     * Observable of the currently signed-in user's JWT token used to identify the user to a Firebase service (or null).\n     */\n    idToken;\n    /**\n     * Observable of the currently signed-in user (or null).\n     */\n    user;\n    /**\n     * Observable of the currently signed-in user's IdTokenResult object which contains the ID token JWT string and other\n     * helper properties for getting different data associated with the token as well as all the decoded payload claims\n     * (or null).\n     */\n    idTokenResult;\n    /**\n     * Observable of the currently signed-in user's credential, or null\n     */\n    credential;\n    constructor(options, name, \n    // eslint-disable-next-line @typescript-eslint/ban-types\n    platformId, zone, schedulers, useEmulator, // can't use the tuple here\n    settings, // can't use firebase.auth.AuthSettings here\n    tenantId, languageCode, useDeviceLanguage, persistence, _appCheckInstances) {\n        const logins = new Subject();\n        const auth = of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(() => zone.runOutsideAngular(() => import('firebase/compat/auth'))), map(() => _firebaseAppFactory(options, zone, name)), map(app => ɵauthFactory(app, zone, useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence)), shareReplay({ bufferSize: 1, refCount: false }));\n        if (isPlatformServer(platformId)) {\n            this.authState = this.user = this.idToken = this.idTokenResult = this.credential = of(null);\n        }\n        else {\n            // HACK, as we're exporting auth.Auth, rather than auth, developers importing firebase.auth\n            //       (e.g, `import { auth } from 'firebase/compat/app'`) are getting an undefined auth object unexpectedly\n            //       as we're completely lazy. Let's eagerly load the Auth SDK here.\n            //       There could potentially be race conditions still... but this greatly decreases the odds while\n            //       we reevaluate the API.\n            auth.pipe(first()).subscribe();\n            const redirectResult = auth.pipe(switchMap(auth => auth.getRedirectResult().then(it => it, () => null)), keepUnstableUntilFirst, shareReplay({ bufferSize: 1, refCount: false }));\n            const authStateChanged = auth.pipe(switchMap(auth => new Observable(sub => ({ unsubscribe: zone.runOutsideAngular(() => auth.onAuthStateChanged(next => sub.next(next), err => sub.error(err), () => sub.complete())) }))));\n            const idTokenChanged = auth.pipe(switchMap(auth => new Observable(sub => ({ unsubscribe: zone.runOutsideAngular(() => auth.onIdTokenChanged(next => sub.next(next), err => sub.error(err), () => sub.complete())) }))));\n            this.authState = redirectResult.pipe(switchMapTo(authStateChanged), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n            this.user = redirectResult.pipe(switchMapTo(idTokenChanged), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n            this.idToken = this.user.pipe(switchMap(user => user ? from(user.getIdToken()) : of(null)));\n            this.idTokenResult = this.user.pipe(switchMap(user => user ? from(user.getIdTokenResult()) : of(null)));\n            this.credential = merge(redirectResult, logins, \n            // pipe in null authState to make credential zipable, just a weird devexp if\n            // authState and user go null to still have a credential\n            this.authState.pipe(filter(it => !it))).pipe(\n            // handle the { user: { } } when a user is already logged in, rather have null\n            // TODO handle the type corcersion better\n            map(credential => credential?.user ? credential : null), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n        }\n        return _lazySDKProxy(this, auth, zone, { spy: {\n                apply: (name, _, val) => {\n                    // If they call a signIn or createUser function listen into the promise\n                    // this will give us the user credential, push onto the logins Subject\n                    // to be consumed in .credential\n                    if (name.startsWith('signIn') || name.startsWith('createUser')) {\n                        // TODO fix the types, the trouble is UserCredential has everything optional\n                        val.then((user) => logins.next(user));\n                    }\n                }\n            } });\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.0.0\", ngImport: i0, type: AngularFireAuth, deps: [{ token: FIREBASE_OPTIONS }, { token: FIREBASE_APP_NAME, optional: true }, { token: PLATFORM_ID }, { token: i0.NgZone }, { token: i1.ɵAngularFireSchedulers }, { token: USE_EMULATOR, optional: true }, { token: SETTINGS, optional: true }, { token: TENANT_ID, optional: true }, { token: LANGUAGE_CODE, optional: true }, { token: USE_DEVICE_LANGUAGE, optional: true }, { token: PERSISTENCE, optional: true }, { token: i2.AppCheckInstances, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.0.0\", ngImport: i0, type: AngularFireAuth, providedIn: 'any' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.0.0\", ngImport: i0, type: AngularFireAuth, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'any'\n                }]\n        }], ctorParameters: () => [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [FIREBASE_OPTIONS]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [FIREBASE_APP_NAME]\n                }] }, { type: Object, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }, { type: i0.NgZone }, { type: i1.ɵAngularFireSchedulers }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [USE_EMULATOR]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [SETTINGS]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TENANT_ID]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [LANGUAGE_CODE]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [USE_DEVICE_LANGUAGE]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [PERSISTENCE]\n                }] }, { type: i2.AppCheckInstances, decorators: [{\n                    type: Optional\n                }] }] });\n_applyMixins(AngularFireAuth, [proxyPolyfillCompat]);\n\nclass AngularFireAuthModule {\n    constructor() {\n        firebase.registerVersion('angularfire', VERSION.full, 'auth-compat');\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.0.0\", ngImport: i0, type: AngularFireAuthModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"18.0.0\", ngImport: i0, type: AngularFireAuthModule });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"18.0.0\", ngImport: i0, type: AngularFireAuthModule, providers: [AngularFireAuth] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.0.0\", ngImport: i0, type: AngularFireAuthModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    providers: [AngularFireAuth]\n                }]\n        }], ctorParameters: () => [] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngularFireAuth, AngularFireAuthModule, LANGUAGE_CODE, PERSISTENCE, SETTINGS, TENANT_ID, USE_DEVICE_LANGUAGE, USE_EMULATOR, ɵauthFactory };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}