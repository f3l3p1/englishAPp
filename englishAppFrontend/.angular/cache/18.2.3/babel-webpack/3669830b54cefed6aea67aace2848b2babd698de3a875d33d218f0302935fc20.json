{"ast":null,"code":"import _asyncToGenerator from \"/Users/user/Documents/Workspace/englishApp/englishAppFrontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _defineProperty from \"/Users/user/Documents/Workspace/englishApp/englishAppFrontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, Optional, InjectionToken, inject, NgZone, ApplicationRef, Injector, createComponent, TemplateRef, Directive, ContentChild, EventEmitter, ViewContainerRef, EnvironmentInjector, Attribute, SkipSelf, Input, Output, reflectComponentType, HostListener, ElementRef, ViewChild } from '@angular/core';\nimport * as i3 from '@angular/router';\nimport { NavigationStart, PRIMARY_OUTLET, ChildrenOutletContexts, ActivatedRoute, Router } from '@angular/router';\nimport * as i1 from '@angular/common';\nimport { DOCUMENT } from '@angular/common';\nimport { isPlatform, getPlatforms, LIFECYCLE_WILL_ENTER, LIFECYCLE_DID_ENTER, LIFECYCLE_WILL_LEAVE, LIFECYCLE_DID_LEAVE, LIFECYCLE_WILL_UNLOAD, componentOnReady } from '@ionic/core/components';\nimport { Subject, fromEvent, BehaviorSubject, combineLatest, of } from 'rxjs';\nimport { __decorate } from 'tslib';\nimport { filter, switchMap, distinctUntilChanged } from 'rxjs/operators';\nimport { NgControl } from '@angular/forms';\nconst _c0 = [\"tabsInner\"];\nclass MenuController {\n  constructor(menuController) {\n    _defineProperty(this, \"menuController\", void 0);\n    this.menuController = menuController;\n  }\n  /**\n   * Programmatically open the Menu.\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return returns a promise when the menu is fully opened\n   */\n  open(menuId) {\n    return this.menuController.open(menuId);\n  }\n  /**\n   * Programmatically close the Menu. If no `menuId` is given as the first\n   * argument then it'll close any menu which is open. If a `menuId`\n   * is given then it'll close that exact menu.\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return returns a promise when the menu is fully closed\n   */\n  close(menuId) {\n    return this.menuController.close(menuId);\n  }\n  /**\n   * Toggle the menu. If it's closed, it will open, and if opened, it\n   * will close.\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return returns a promise when the menu has been toggled\n   */\n  toggle(menuId) {\n    return this.menuController.toggle(menuId);\n  }\n  /**\n   * Used to enable or disable a menu. For example, there could be multiple\n   * left menus, but only one of them should be able to be opened at the same\n   * time. If there are multiple menus on the same side, then enabling one menu\n   * will also automatically disable all the others that are on the same side.\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return Returns the instance of the menu, which is useful for chaining.\n   */\n  enable(shouldEnable, menuId) {\n    return this.menuController.enable(shouldEnable, menuId);\n  }\n  /**\n   * Used to enable or disable the ability to swipe open the menu.\n   * @param shouldEnable  True if it should be swipe-able, false if not.\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return Returns the instance of the menu, which is useful for chaining.\n   */\n  swipeGesture(shouldEnable, menuId) {\n    return this.menuController.swipeGesture(shouldEnable, menuId);\n  }\n  /**\n   * @param [menuId] Optionally get the menu by its id, or side.\n   * @return Returns true if the specified menu is currently open, otherwise false.\n   * If the menuId is not specified, it returns true if ANY menu is currenly open.\n   */\n  isOpen(menuId) {\n    return this.menuController.isOpen(menuId);\n  }\n  /**\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return Returns true if the menu is currently enabled, otherwise false.\n   */\n  isEnabled(menuId) {\n    return this.menuController.isEnabled(menuId);\n  }\n  /**\n   * Used to get a menu instance. If a `menuId` is not provided then it'll\n   * return the first menu found. If a `menuId` is `left` or `right`, then\n   * it'll return the enabled menu on that side. Otherwise, if a `menuId` is\n   * provided, then it'll try to find the menu using the menu's `id`\n   * property. If a menu is not found then it'll return `null`.\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return Returns the instance of the menu if found, otherwise `null`.\n   */\n  get(menuId) {\n    return this.menuController.get(menuId);\n  }\n  /**\n   * @return Returns the instance of the menu already opened, otherwise `null`.\n   */\n  getOpen() {\n    return this.menuController.getOpen();\n  }\n  /**\n   * @return Returns an array of all menu instances.\n   */\n  getMenus() {\n    return this.menuController.getMenus();\n  }\n  registerAnimation(name, animation) {\n    return this.menuController.registerAnimation(name, animation);\n  }\n  isAnimating() {\n    return this.menuController.isAnimating();\n  }\n  _getOpenSync() {\n    return this.menuController._getOpenSync();\n  }\n  _createAnimation(type, menuCmp) {\n    return this.menuController._createAnimation(type, menuCmp);\n  }\n  _register(menu) {\n    return this.menuController._register(menu);\n  }\n  _unregister(menu) {\n    return this.menuController._unregister(menu);\n  }\n  _setOpen(menu, shouldOpen, animated) {\n    return this.menuController._setOpen(menu, shouldOpen, animated);\n  }\n}\nlet DomController = /*#__PURE__*/(() => {\n  var _DomController;\n  class DomController {\n    /**\n     * Schedules a task to run during the READ phase of the next frame.\n     * This task should only read the DOM, but never modify it.\n     */\n    read(cb) {\n      getQueue().read(cb);\n    }\n    /**\n     * Schedules a task to run during the WRITE phase of the next frame.\n     * This task should write the DOM, but never READ it.\n     */\n    write(cb) {\n      getQueue().write(cb);\n    }\n    /** @nocollapse */\n  }\n  _DomController = DomController;\n  _defineProperty(DomController, \"\\u0275fac\", function _DomController_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _DomController)();\n  });\n  /** @nocollapse */\n  _defineProperty(DomController, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _DomController,\n    factory: _DomController.ɵfac,\n    providedIn: 'root'\n  }));\n  return DomController;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst getQueue = () => {\n  const win = typeof window !== 'undefined' ? window : null;\n  if (win != null) {\n    const Ionic = win.Ionic;\n    if (Ionic !== null && Ionic !== void 0 && Ionic.queue) {\n      return Ionic.queue;\n    }\n    return {\n      read: cb => win.requestAnimationFrame(cb),\n      write: cb => win.requestAnimationFrame(cb)\n    };\n  }\n  return {\n    read: cb => cb(),\n    write: cb => cb()\n  };\n};\nlet Platform = /*#__PURE__*/(() => {\n  var _Platform;\n  class Platform {\n    constructor(doc, zone) {\n      _defineProperty(this, \"doc\", void 0);\n      _defineProperty(this, \"_readyPromise\", void 0);\n      _defineProperty(this, \"win\", void 0);\n      /**\n       * @hidden\n       */\n      _defineProperty(this, \"backButton\", new Subject());\n      /**\n       * The keyboardDidShow event emits when the\n       * on-screen keyboard is presented.\n       */\n      _defineProperty(this, \"keyboardDidShow\", new Subject());\n      /**\n       * The keyboardDidHide event emits when the\n       * on-screen keyboard is hidden.\n       */\n      _defineProperty(this, \"keyboardDidHide\", new Subject());\n      /**\n       * The pause event emits when the native platform puts the application\n       * into the background, typically when the user switches to a different\n       * application. This event would emit when a Cordova app is put into\n       * the background, however, it would not fire on a standard web browser.\n       */\n      _defineProperty(this, \"pause\", new Subject());\n      /**\n       * The resume event emits when the native platform pulls the application\n       * out from the background. This event would emit when a Cordova app comes\n       * out from the background, however, it would not fire on a standard web browser.\n       */\n      _defineProperty(this, \"resume\", new Subject());\n      /**\n       * The resize event emits when the browser window has changed dimensions. This\n       * could be from a browser window being physically resized, or from a device\n       * changing orientation.\n       */\n      _defineProperty(this, \"resize\", new Subject());\n      this.doc = doc;\n      zone.run(() => {\n        var _this$win;\n        this.win = doc.defaultView;\n        this.backButton.subscribeWithPriority = function (priority, callback) {\n          return this.subscribe(ev => {\n            return ev.register(priority, processNextHandler => zone.run(() => callback(processNextHandler)));\n          });\n        };\n        proxyEvent(this.pause, doc, 'pause', zone);\n        proxyEvent(this.resume, doc, 'resume', zone);\n        proxyEvent(this.backButton, doc, 'ionBackButton', zone);\n        proxyEvent(this.resize, this.win, 'resize', zone);\n        proxyEvent(this.keyboardDidShow, this.win, 'ionKeyboardDidShow', zone);\n        proxyEvent(this.keyboardDidHide, this.win, 'ionKeyboardDidHide', zone);\n        let readyResolve;\n        this._readyPromise = new Promise(res => {\n          readyResolve = res;\n        });\n        if ((_this$win = this.win) !== null && _this$win !== void 0 && _this$win['cordova']) {\n          doc.addEventListener('deviceready', () => {\n            readyResolve('cordova');\n          }, {\n            once: true\n          });\n        } else {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          readyResolve('dom');\n        }\n      });\n    }\n    /**\n     * @returns returns true/false based on platform.\n     * @description\n     * Depending on the platform the user is on, `is(platformName)` will\n     * return `true` or `false`. Note that the same app can return `true`\n     * for more than one platform name. For example, an app running from\n     * an iPad would return `true` for the platform names: `mobile`,\n     * `ios`, `ipad`, and `tablet`. Additionally, if the app was running\n     * from Cordova then `cordova` would be true, and if it was running\n     * from a web browser on the iPad then `mobileweb` would be `true`.\n     *\n     * ```\n     * import { Platform } from 'ionic-angular';\n     *\n     * @Component({...})\n     * export MyPage {\n     *   constructor(public platform: Platform) {\n     *     if (this.platform.is('ios')) {\n     *       // This will only print when on iOS\n     *       console.log('I am an iOS device!');\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * | Platform Name   | Description                        |\n     * |-----------------|------------------------------------|\n     * | android         | on a device running Android.       |\n     * | capacitor       | on a device running Capacitor.     |\n     * | cordova         | on a device running Cordova.       |\n     * | ios             | on a device running iOS.           |\n     * | ipad            | on an iPad device.                 |\n     * | iphone          | on an iPhone device.               |\n     * | phablet         | on a phablet device.               |\n     * | tablet          | on a tablet device.                |\n     * | electron        | in Electron on a desktop device.   |\n     * | pwa             | as a PWA app.                      |\n     * | mobile          | on a mobile device.                |\n     * | mobileweb       | on a mobile device in a browser.   |\n     * | desktop         | on a desktop device.               |\n     * | hybrid          | is a cordova or capacitor app.     |\n     *\n     */\n    is(platformName) {\n      return isPlatform(this.win, platformName);\n    }\n    /**\n     * @returns the array of platforms\n     * @description\n     * Depending on what device you are on, `platforms` can return multiple values.\n     * Each possible value is a hierarchy of platforms. For example, on an iPhone,\n     * it would return `mobile`, `ios`, and `iphone`.\n     *\n     * ```\n     * import { Platform } from 'ionic-angular';\n     *\n     * @Component({...})\n     * export MyPage {\n     *   constructor(public platform: Platform) {\n     *     // This will print an array of the current platforms\n     *     console.log(this.platform.platforms());\n     *   }\n     * }\n     * ```\n     */\n    platforms() {\n      return getPlatforms(this.win);\n    }\n    /**\n     * Returns a promise when the platform is ready and native functionality\n     * can be called. If the app is running from within a web browser, then\n     * the promise will resolve when the DOM is ready. When the app is running\n     * from an application engine such as Cordova, then the promise will\n     * resolve when Cordova triggers the `deviceready` event.\n     *\n     * The resolved value is the `readySource`, which states which platform\n     * ready was used. For example, when Cordova is ready, the resolved ready\n     * source is `cordova`. The default ready source value will be `dom`. The\n     * `readySource` is useful if different logic should run depending on the\n     * platform the app is running from. For example, only Cordova can execute\n     * the status bar plugin, so the web should not run status bar plugin logic.\n     *\n     * ```\n     * import { Component } from '@angular/core';\n     * import { Platform } from 'ionic-angular';\n     *\n     * @Component({...})\n     * export MyApp {\n     *   constructor(public platform: Platform) {\n     *     this.platform.ready().then((readySource) => {\n     *       console.log('Platform ready from', readySource);\n     *       // Platform now ready, execute any required native code\n     *     });\n     *   }\n     * }\n     * ```\n     */\n    ready() {\n      return this._readyPromise;\n    }\n    /**\n     * Returns if this app is using right-to-left language direction or not.\n     * We recommend the app's `index.html` file already has the correct `dir`\n     * attribute value set, such as `<html dir=\"ltr\">` or `<html dir=\"rtl\">`.\n     * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)\n     */\n    get isRTL() {\n      return this.doc.dir === 'rtl';\n    }\n    /**\n     * Get the query string parameter\n     */\n    getQueryParam(key) {\n      return readQueryParam(this.win.location.href, key);\n    }\n    /**\n     * Returns `true` if the app is in landscape mode.\n     */\n    isLandscape() {\n      return !this.isPortrait();\n    }\n    /**\n     * Returns `true` if the app is in portrait mode.\n     */\n    isPortrait() {\n      var _this$win$matchMedia, _this$win2;\n      return (_this$win$matchMedia = (_this$win2 = this.win).matchMedia) === null || _this$win$matchMedia === void 0 ? void 0 : _this$win$matchMedia.call(_this$win2, '(orientation: portrait)').matches;\n    }\n    testUserAgent(expression) {\n      const nav = this.win.navigator;\n      return !!(nav !== null && nav !== void 0 && nav.userAgent && nav.userAgent.indexOf(expression) >= 0);\n    }\n    /**\n     * Get the current url.\n     */\n    url() {\n      return this.win.location.href;\n    }\n    /**\n     * Gets the width of the platform's viewport using `window.innerWidth`.\n     */\n    width() {\n      return this.win.innerWidth;\n    }\n    /**\n     * Gets the height of the platform's viewport using `window.innerHeight`.\n     */\n    height() {\n      return this.win.innerHeight;\n    }\n    /** @nocollapse */\n  }\n  _Platform = Platform;\n  _defineProperty(Platform, \"\\u0275fac\", function _Platform_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _Platform)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i0.NgZone));\n  });\n  /** @nocollapse */\n  _defineProperty(Platform, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _Platform,\n    factory: _Platform.ɵfac,\n    providedIn: 'root'\n  }));\n  return Platform;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst readQueryParam = (url, key) => {\n  key = key.replace(/[[\\]\\\\]/g, '\\\\$&');\n  const regex = new RegExp('[\\\\?&]' + key + '=([^&#]*)');\n  const results = regex.exec(url);\n  return results ? decodeURIComponent(results[1].replace(/\\+/g, ' ')) : null;\n};\nconst proxyEvent = (emitter, el, eventName, zone) => {\n  if (el) {\n    el.addEventListener(eventName, ev => {\n      /**\n       * `zone.run` is required to make sure that we are running inside the Angular zone\n       * at all times. This is necessary since an app that has Capacitor will\n       * override the `document.addEventListener` with its own implementation.\n       * The override causes the event to no longer be in the Angular zone.\n       */\n      zone.run(() => {\n        // ?? cordova might emit \"null\" events\n        const value = ev != null ? ev.detail : undefined;\n        emitter.next(value);\n      });\n    });\n  }\n};\nlet NavController = /*#__PURE__*/(() => {\n  var _NavController;\n  class NavController {\n    constructor(platform, location, serializer, router) {\n      _defineProperty(this, \"location\", void 0);\n      _defineProperty(this, \"serializer\", void 0);\n      _defineProperty(this, \"router\", void 0);\n      _defineProperty(this, \"topOutlet\", void 0);\n      _defineProperty(this, \"direction\", DEFAULT_DIRECTION);\n      _defineProperty(this, \"animated\", DEFAULT_ANIMATED);\n      _defineProperty(this, \"animationBuilder\", void 0);\n      _defineProperty(this, \"guessDirection\", 'forward');\n      _defineProperty(this, \"guessAnimation\", void 0);\n      _defineProperty(this, \"lastNavId\", -1);\n      this.location = location;\n      this.serializer = serializer;\n      this.router = router;\n      // Subscribe to router events to detect direction\n      if (router) {\n        router.events.subscribe(ev => {\n          if (ev instanceof NavigationStart) {\n            // restoredState is set if the browser back/forward button is used\n            const id = ev.restoredState ? ev.restoredState.navigationId : ev.id;\n            this.guessDirection = this.guessAnimation = id < this.lastNavId ? 'back' : 'forward';\n            this.lastNavId = this.guessDirection === 'forward' ? ev.id : id;\n          }\n        });\n      }\n      // Subscribe to backButton events\n      platform.backButton.subscribeWithPriority(0, processNextHandler => {\n        this.pop();\n        processNextHandler();\n      });\n    }\n    /**\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n     * it's equivalent to calling `this.router.navigateByUrl()`, but it's explicit about the **direction** of the transition.\n     *\n     * Going **forward** means that a new page is going to be pushed to the stack of the outlet (ion-router-outlet),\n     * and that it will show a \"forward\" animation by default.\n     *\n     * Navigating forward can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n     *\n     * ```html\n     * <a routerLink=\"/path/to/page\" routerDirection=\"forward\">Link</a>\n     * ```\n     */\n    navigateForward(url, options = {}) {\n      this.setDirection('forward', options.animated, options.animationDirection, options.animation);\n      return this.navigate(url, options);\n    }\n    /**\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n     * it's equivalent to calling:\n     *\n     * ```ts\n     * this.navController.setDirection('back');\n     * this.router.navigateByUrl(path);\n     * ```\n     *\n     * Going **back** means that all the pages in the stack until the navigated page is found will be popped,\n     * and that it will show a \"back\" animation by default.\n     *\n     * Navigating back can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n     *\n     * ```html\n     * <a routerLink=\"/path/to/page\" routerDirection=\"back\">Link</a>\n     * ```\n     */\n    navigateBack(url, options = {}) {\n      this.setDirection('back', options.animated, options.animationDirection, options.animation);\n      return this.navigate(url, options);\n    }\n    /**\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n     * it's equivalent to calling:\n     *\n     * ```ts\n     * this.navController.setDirection('root');\n     * this.router.navigateByUrl(path);\n     * ```\n     *\n     * Going **root** means that all existing pages in the stack will be removed,\n     * and the navigated page will become the single page in the stack.\n     *\n     * Navigating root can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n     *\n     * ```html\n     * <a routerLink=\"/path/to/page\" routerDirection=\"root\">Link</a>\n     * ```\n     */\n    navigateRoot(url, options = {}) {\n      this.setDirection('root', options.animated, options.animationDirection, options.animation);\n      return this.navigate(url, options);\n    }\n    /**\n     * Same as [Location](https://angular.io/api/common/Location)'s back() method.\n     * It will use the standard `window.history.back()` under the hood, but featuring a `back` animation\n     * by default.\n     */\n    back(options = {\n      animated: true,\n      animationDirection: 'back'\n    }) {\n      this.setDirection('back', options.animated, options.animationDirection, options.animation);\n      return this.location.back();\n    }\n    /**\n     * This methods goes back in the context of Ionic's stack navigation.\n     *\n     * It recursively finds the top active `ion-router-outlet` and calls `pop()`.\n     * This is the recommended way to go back when you are using `ion-router-outlet`.\n     *\n     * Resolves to `true` if it was able to pop.\n     */\n    pop() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        let outlet = _this.topOutlet;\n        while (outlet) {\n          if (yield outlet.pop()) {\n            return true;\n          } else {\n            outlet = outlet.parentOutlet;\n          }\n        }\n        return false;\n      })();\n    }\n    /**\n     * This methods specifies the direction of the next navigation performed by the Angular router.\n     *\n     * `setDirection()` does not trigger any transition, it just sets some flags to be consumed by `ion-router-outlet`.\n     *\n     * It's recommended to use `navigateForward()`, `navigateBack()` and `navigateRoot()` instead of `setDirection()`.\n     */\n    setDirection(direction, animated, animationDirection, animationBuilder) {\n      this.direction = direction;\n      this.animated = getAnimation(direction, animated, animationDirection);\n      this.animationBuilder = animationBuilder;\n    }\n    /**\n     * @internal\n     */\n    setTopOutlet(outlet) {\n      this.topOutlet = outlet;\n    }\n    /**\n     * @internal\n     */\n    consumeTransition() {\n      let direction = 'root';\n      let animation;\n      const animationBuilder = this.animationBuilder;\n      if (this.direction === 'auto') {\n        direction = this.guessDirection;\n        animation = this.guessAnimation;\n      } else {\n        animation = this.animated;\n        direction = this.direction;\n      }\n      this.direction = DEFAULT_DIRECTION;\n      this.animated = DEFAULT_ANIMATED;\n      this.animationBuilder = undefined;\n      return {\n        direction,\n        animation,\n        animationBuilder\n      };\n    }\n    navigate(url, options) {\n      if (Array.isArray(url)) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this.router.navigate(url, options);\n      } else {\n        /**\n         * navigateByUrl ignores any properties that\n         * would change the url, so things like queryParams\n         * would be ignored unless we create a url tree\n         * More Info: https://github.com/angular/angular/issues/18798\n         */\n        const urlTree = this.serializer.parse(url.toString());\n        if (options.queryParams !== undefined) {\n          urlTree.queryParams = {\n            ...options.queryParams\n          };\n        }\n        if (options.fragment !== undefined) {\n          urlTree.fragment = options.fragment;\n        }\n        /**\n         * `navigateByUrl` will still apply `NavigationExtras` properties\n         * that do not modify the url, such as `replaceUrl` which is why\n         * `options` is passed in here.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this.router.navigateByUrl(urlTree, options);\n      }\n    }\n    /** @nocollapse */\n  }\n  _NavController = NavController;\n  _defineProperty(NavController, \"\\u0275fac\", function _NavController_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NavController)(i0.ɵɵinject(Platform), i0.ɵɵinject(i1.Location), i0.ɵɵinject(i3.UrlSerializer), i0.ɵɵinject(i3.Router, 8));\n  });\n  /** @nocollapse */\n  _defineProperty(NavController, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _NavController,\n    factory: _NavController.ɵfac,\n    providedIn: 'root'\n  }));\n  return NavController;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst getAnimation = (direction, animated, animationDirection) => {\n  if (animated === false) {\n    return undefined;\n  }\n  if (animationDirection !== undefined) {\n    return animationDirection;\n  }\n  if (direction === 'forward' || direction === 'back') {\n    return direction;\n  } else if (direction === 'root' && animated === true) {\n    return 'forward';\n  }\n  return undefined;\n};\nconst DEFAULT_DIRECTION = 'auto';\nconst DEFAULT_ANIMATED = undefined;\nlet Config = /*#__PURE__*/(() => {\n  var _Config;\n  class Config {\n    get(key, fallback) {\n      const c = getConfig();\n      if (c) {\n        return c.get(key, fallback);\n      }\n      return null;\n    }\n    getBoolean(key, fallback) {\n      const c = getConfig();\n      if (c) {\n        return c.getBoolean(key, fallback);\n      }\n      return false;\n    }\n    getNumber(key, fallback) {\n      const c = getConfig();\n      if (c) {\n        return c.getNumber(key, fallback);\n      }\n      return 0;\n    }\n    /** @nocollapse */\n  }\n  _Config = Config;\n  _defineProperty(Config, \"\\u0275fac\", function _Config_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _Config)();\n  });\n  /** @nocollapse */\n  _defineProperty(Config, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _Config,\n    factory: _Config.ɵfac,\n    providedIn: 'root'\n  }));\n  return Config;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst ConfigToken = new InjectionToken('USERCONFIG');\nconst getConfig = () => {\n  if (typeof window !== 'undefined') {\n    const Ionic = window.Ionic;\n    if (Ionic !== null && Ionic !== void 0 && Ionic.config) {\n      return Ionic.config;\n    }\n  }\n  return null;\n};\n\n/**\n * @description\n * NavParams are an object that exists on a page and can contain data for that particular view.\n * Similar to how data was pass to a view in V1 with `$stateParams`, NavParams offer a much more flexible\n * option with a simple `get` method.\n *\n * @usage\n * ```ts\n * import { NavParams } from '@ionic/angular';\n *\n * export class MyClass{\n *\n *  constructor(navParams: NavParams){\n *    // userParams is an object we have in our nav-parameters\n *    navParams.get('userParams');\n *  }\n *\n * }\n * ```\n */\nclass NavParams {\n  constructor(data = {}) {\n    _defineProperty(this, \"data\", void 0);\n    this.data = data;\n    console.warn(`[Ionic Warning]: NavParams has been deprecated in favor of using Angular's input API. Developers should migrate to either the @Input decorator or the Signals-based input API.`);\n  }\n  /**\n   * Get the value of a nav-parameter for the current view\n   *\n   * ```ts\n   * import { NavParams } from 'ionic-angular';\n   *\n   * export class MyClass{\n   *  constructor(public navParams: NavParams){\n   *    // userParams is an object we have in our nav-parameters\n   *    this.navParams.get('userParams');\n   *  }\n   * }\n   * ```\n   *\n   * @param param Which param you want to look up\n   */\n  get(param) {\n    return this.data[param];\n  }\n}\n\n// TODO(FW-2827): types\nlet AngularDelegate = /*#__PURE__*/(() => {\n  var _AngularDelegate;\n  class AngularDelegate {\n    constructor() {\n      _defineProperty(this, \"zone\", inject(NgZone));\n      _defineProperty(this, \"applicationRef\", inject(ApplicationRef));\n      _defineProperty(this, \"config\", inject(ConfigToken));\n    }\n    create(environmentInjector, injector, elementReferenceKey) {\n      var _this$config$useSetIn;\n      return new AngularFrameworkDelegate(environmentInjector, injector, this.applicationRef, this.zone, elementReferenceKey, (_this$config$useSetIn = this.config.useSetInputAPI) !== null && _this$config$useSetIn !== void 0 ? _this$config$useSetIn : false);\n    }\n    /** @nocollapse */\n  }\n  _AngularDelegate = AngularDelegate;\n  _defineProperty(AngularDelegate, \"\\u0275fac\", function _AngularDelegate_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _AngularDelegate)();\n  });\n  /** @nocollapse */\n  _defineProperty(AngularDelegate, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _AngularDelegate,\n    factory: _AngularDelegate.ɵfac\n  }));\n  return AngularDelegate;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass AngularFrameworkDelegate {\n  constructor(environmentInjector, injector, applicationRef, zone, elementReferenceKey, enableSignalsSupport) {\n    _defineProperty(this, \"environmentInjector\", void 0);\n    _defineProperty(this, \"injector\", void 0);\n    _defineProperty(this, \"applicationRef\", void 0);\n    _defineProperty(this, \"zone\", void 0);\n    _defineProperty(this, \"elementReferenceKey\", void 0);\n    _defineProperty(this, \"enableSignalsSupport\", void 0);\n    _defineProperty(this, \"elRefMap\", new WeakMap());\n    _defineProperty(this, \"elEventsMap\", new WeakMap());\n    this.environmentInjector = environmentInjector;\n    this.injector = injector;\n    this.applicationRef = applicationRef;\n    this.zone = zone;\n    this.elementReferenceKey = elementReferenceKey;\n    this.enableSignalsSupport = enableSignalsSupport;\n  }\n  attachViewToDom(container, component, params, cssClasses) {\n    return this.zone.run(() => {\n      return new Promise(resolve => {\n        const componentProps = {\n          ...params\n        };\n        /**\n         * Ionic Angular passes a reference to a modal\n         * or popover that can be accessed using a\n         * variable in the overlay component. If\n         * elementReferenceKey is defined, then we should\n         * pass a reference to the component using\n         * elementReferenceKey as the key.\n         */\n        if (this.elementReferenceKey !== undefined) {\n          componentProps[this.elementReferenceKey] = container;\n        }\n        const el = attachView(this.zone, this.environmentInjector, this.injector, this.applicationRef, this.elRefMap, this.elEventsMap, container, component, componentProps, cssClasses, this.elementReferenceKey, this.enableSignalsSupport);\n        resolve(el);\n      });\n    });\n  }\n  removeViewFromDom(_container, component) {\n    return this.zone.run(() => {\n      return new Promise(resolve => {\n        const componentRef = this.elRefMap.get(component);\n        if (componentRef) {\n          componentRef.destroy();\n          this.elRefMap.delete(component);\n          const unbindEvents = this.elEventsMap.get(component);\n          if (unbindEvents) {\n            unbindEvents();\n            this.elEventsMap.delete(component);\n          }\n        }\n        resolve();\n      });\n    });\n  }\n}\nconst attachView = (zone, environmentInjector, injector, applicationRef, elRefMap, elEventsMap, container, component, params, cssClasses, elementReferenceKey, enableSignalsSupport) => {\n  /**\n   * Wraps the injector with a custom injector that\n   * provides NavParams to the component.\n   *\n   * NavParams is a legacy feature from Ionic v3 that allows\n   * Angular developers to provide data to a component\n   * and access it by providing NavParams as a dependency\n   * in the constructor.\n   *\n   * The modern approach is to access the data directly\n   * from the component's class instance.\n   */\n  const childInjector = Injector.create({\n    providers: getProviders(params),\n    parent: injector\n  });\n  const componentRef = createComponent(component, {\n    environmentInjector,\n    elementInjector: childInjector\n  });\n  const instance = componentRef.instance;\n  const hostElement = componentRef.location.nativeElement;\n  if (params) {\n    /**\n     * For modals and popovers, a reference to the component is\n     * added to `params` during the call to attachViewToDom. If\n     * a reference using this name is already set, this means\n     * the app is trying to use the name as a component prop,\n     * which will cause collisions.\n     */\n    if (elementReferenceKey && instance[elementReferenceKey] !== undefined) {\n      console.error(`[Ionic Error]: ${elementReferenceKey} is a reserved property when using ${container.tagName.toLowerCase()}. Rename or remove the \"${elementReferenceKey}\" property from ${component.name}.`);\n    }\n    /**\n     * Angular 14.1 added support for setInput\n     * so we need to fall back to Object.assign\n     * for Angular 14.0.\n     */\n    if (enableSignalsSupport === true && componentRef.setInput !== undefined) {\n      const {\n        modal,\n        popover,\n        ...otherParams\n      } = params;\n      /**\n       * Any key/value pairs set in componentProps\n       * must be set as inputs on the component instance.\n       */\n      for (const key in otherParams) {\n        componentRef.setInput(key, otherParams[key]);\n      }\n      /**\n       * Using setInput will cause an error when\n       * setting modal/popover on a component that\n       * does not define them as an input. For backwards\n       * compatibility purposes we fall back to using\n       * Object.assign for these properties.\n       */\n      if (modal !== undefined) {\n        Object.assign(instance, {\n          modal\n        });\n      }\n      if (popover !== undefined) {\n        Object.assign(instance, {\n          popover\n        });\n      }\n    } else {\n      Object.assign(instance, params);\n    }\n  }\n  if (cssClasses) {\n    for (const cssClass of cssClasses) {\n      hostElement.classList.add(cssClass);\n    }\n  }\n  const unbindEvents = bindLifecycleEvents(zone, instance, hostElement);\n  container.appendChild(hostElement);\n  applicationRef.attachView(componentRef.hostView);\n  elRefMap.set(hostElement, componentRef);\n  elEventsMap.set(hostElement, unbindEvents);\n  return hostElement;\n};\nconst LIFECYCLES = [LIFECYCLE_WILL_ENTER, LIFECYCLE_DID_ENTER, LIFECYCLE_WILL_LEAVE, LIFECYCLE_DID_LEAVE, LIFECYCLE_WILL_UNLOAD];\nconst bindLifecycleEvents = (zone, instance, element) => {\n  return zone.run(() => {\n    const unregisters = LIFECYCLES.filter(eventName => typeof instance[eventName] === 'function').map(eventName => {\n      const handler = ev => instance[eventName](ev.detail);\n      element.addEventListener(eventName, handler);\n      return () => element.removeEventListener(eventName, handler);\n    });\n    return () => unregisters.forEach(fn => fn());\n  });\n};\nconst NavParamsToken = new InjectionToken('NavParamsToken');\nconst getProviders = params => {\n  return [{\n    provide: NavParamsToken,\n    useValue: params\n  }, {\n    provide: NavParams,\n    useFactory: provideNavParamsInjectable,\n    deps: [NavParamsToken]\n  }];\n};\nconst provideNavParamsInjectable = params => {\n  return new NavParams(params);\n};\n\n// TODO: Is there a way we can grab this from angular-component-lib instead?\n/* eslint-disable */\n/* tslint:disable */\nconst proxyInputs = (Cmp, inputs) => {\n  const Prototype = Cmp.prototype;\n  inputs.forEach(item => {\n    Object.defineProperty(Prototype, item, {\n      get() {\n        return this.el[item];\n      },\n      set(val) {\n        this.z.runOutsideAngular(() => this.el[item] = val);\n      }\n    });\n  });\n};\nconst proxyMethods = (Cmp, methods) => {\n  const Prototype = Cmp.prototype;\n  methods.forEach(methodName => {\n    Prototype[methodName] = function () {\n      const args = arguments;\n      return this.z.runOutsideAngular(() => this.el[methodName].apply(this.el, args));\n    };\n  });\n};\nconst proxyOutputs = (instance, el, events) => {\n  events.forEach(eventName => instance[eventName] = fromEvent(el, eventName));\n};\n// tslint:disable-next-line: only-arrow-functions\nfunction ProxyCmp(opts) {\n  const decorator = function (cls) {\n    const {\n      defineCustomElementFn,\n      inputs,\n      methods\n    } = opts;\n    if (defineCustomElementFn !== undefined) {\n      defineCustomElementFn();\n    }\n    if (inputs) {\n      proxyInputs(cls, inputs);\n    }\n    if (methods) {\n      proxyMethods(cls, methods);\n    }\n    return cls;\n  };\n  return decorator;\n}\nconst POPOVER_INPUTS = ['alignment', 'animated', 'arrow', 'keepContentsMounted', 'backdropDismiss', 'cssClass', 'dismissOnSelect', 'enterAnimation', 'event', 'focusTrap', 'isOpen', 'keyboardClose', 'leaveAnimation', 'mode', 'showBackdrop', 'translucent', 'trigger', 'triggerAction', 'reference', 'size', 'side'];\nconst POPOVER_METHODS = ['present', 'dismiss', 'onDidDismiss', 'onWillDismiss'];\nlet IonPopover = /*#__PURE__*/(() => {\n  var _IonPopover;\n  let IonPopover = (_IonPopover = class IonPopover {\n    constructor(c, r, z) {\n      _defineProperty(this, \"z\", void 0);\n      // TODO(FW-2827): type\n      _defineProperty(this, \"template\", void 0);\n      _defineProperty(this, \"isCmpOpen\", false);\n      _defineProperty(this, \"el\", void 0);\n      this.z = z;\n      this.el = r.nativeElement;\n      this.el.addEventListener('ionMount', () => {\n        this.isCmpOpen = true;\n        c.detectChanges();\n      });\n      this.el.addEventListener('didDismiss', () => {\n        this.isCmpOpen = false;\n        c.detectChanges();\n      });\n      proxyOutputs(this, this.el, ['ionPopoverDidPresent', 'ionPopoverWillPresent', 'ionPopoverWillDismiss', 'ionPopoverDidDismiss', 'didPresent', 'willPresent', 'willDismiss', 'didDismiss']);\n    }\n    /** @nocollapse */\n  }, _defineProperty(_IonPopover, \"\\u0275fac\", function _IonPopover_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _IonPopover)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  }), _defineProperty(_IonPopover, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _IonPopover,\n    selectors: [[\"ion-popover\"]],\n    contentQueries: function _IonPopover_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TemplateRef, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n      }\n    },\n    inputs: {\n      alignment: \"alignment\",\n      animated: \"animated\",\n      arrow: \"arrow\",\n      keepContentsMounted: \"keepContentsMounted\",\n      backdropDismiss: \"backdropDismiss\",\n      cssClass: \"cssClass\",\n      dismissOnSelect: \"dismissOnSelect\",\n      enterAnimation: \"enterAnimation\",\n      event: \"event\",\n      focusTrap: \"focusTrap\",\n      isOpen: \"isOpen\",\n      keyboardClose: \"keyboardClose\",\n      leaveAnimation: \"leaveAnimation\",\n      mode: \"mode\",\n      showBackdrop: \"showBackdrop\",\n      translucent: \"translucent\",\n      trigger: \"trigger\",\n      triggerAction: \"triggerAction\",\n      reference: \"reference\",\n      size: \"size\",\n      side: \"side\"\n    }\n  })), _IonPopover);\n  IonPopover = __decorate([ProxyCmp({\n    inputs: POPOVER_INPUTS,\n    methods: POPOVER_METHODS\n  })\n  /**\n   * @Component extends from @Directive\n   * so by defining the inputs here we\n   * do not need to re-define them for the\n   * lazy loaded popover.\n   */], IonPopover);\n  return IonPopover;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst MODAL_INPUTS = ['animated', 'keepContentsMounted', 'backdropBreakpoint', 'backdropDismiss', 'breakpoints', 'canDismiss', 'cssClass', 'enterAnimation', 'event', 'focusTrap', 'handle', 'handleBehavior', 'initialBreakpoint', 'isOpen', 'keyboardClose', 'leaveAnimation', 'mode', 'presentingElement', 'showBackdrop', 'translucent', 'trigger'];\nconst MODAL_METHODS = ['present', 'dismiss', 'onDidDismiss', 'onWillDismiss', 'setCurrentBreakpoint', 'getCurrentBreakpoint'];\nlet IonModal = /*#__PURE__*/(() => {\n  var _IonModal;\n  let IonModal = (_IonModal = class IonModal {\n    constructor(c, r, z) {\n      _defineProperty(this, \"z\", void 0);\n      // TODO(FW-2827): type\n      _defineProperty(this, \"template\", void 0);\n      _defineProperty(this, \"isCmpOpen\", false);\n      _defineProperty(this, \"el\", void 0);\n      this.z = z;\n      this.el = r.nativeElement;\n      this.el.addEventListener('ionMount', () => {\n        this.isCmpOpen = true;\n        c.detectChanges();\n      });\n      this.el.addEventListener('didDismiss', () => {\n        this.isCmpOpen = false;\n        c.detectChanges();\n      });\n      proxyOutputs(this, this.el, ['ionModalDidPresent', 'ionModalWillPresent', 'ionModalWillDismiss', 'ionModalDidDismiss', 'ionBreakpointDidChange', 'didPresent', 'willPresent', 'willDismiss', 'didDismiss']);\n    }\n    /** @nocollapse */\n  }, _defineProperty(_IonModal, \"\\u0275fac\", function _IonModal_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _IonModal)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  }), _defineProperty(_IonModal, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _IonModal,\n    selectors: [[\"ion-modal\"]],\n    contentQueries: function _IonModal_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TemplateRef, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n      }\n    },\n    inputs: {\n      animated: \"animated\",\n      keepContentsMounted: \"keepContentsMounted\",\n      backdropBreakpoint: \"backdropBreakpoint\",\n      backdropDismiss: \"backdropDismiss\",\n      breakpoints: \"breakpoints\",\n      canDismiss: \"canDismiss\",\n      cssClass: \"cssClass\",\n      enterAnimation: \"enterAnimation\",\n      event: \"event\",\n      focusTrap: \"focusTrap\",\n      handle: \"handle\",\n      handleBehavior: \"handleBehavior\",\n      initialBreakpoint: \"initialBreakpoint\",\n      isOpen: \"isOpen\",\n      keyboardClose: \"keyboardClose\",\n      leaveAnimation: \"leaveAnimation\",\n      mode: \"mode\",\n      presentingElement: \"presentingElement\",\n      showBackdrop: \"showBackdrop\",\n      translucent: \"translucent\",\n      trigger: \"trigger\"\n    }\n  })), _IonModal);\n  IonModal = __decorate([ProxyCmp({\n    inputs: MODAL_INPUTS,\n    methods: MODAL_METHODS\n  })\n  /**\n   * @Component extends from @Directive\n   * so by defining the inputs here we\n   * do not need to re-define them for the\n   * lazy loaded popover.\n   */], IonModal);\n  return IonModal;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst insertView = (views, view, direction) => {\n  if (direction === 'root') {\n    return setRoot(views, view);\n  } else if (direction === 'forward') {\n    return setForward(views, view);\n  } else {\n    return setBack(views, view);\n  }\n};\nconst setRoot = (views, view) => {\n  views = views.filter(v => v.stackId !== view.stackId);\n  views.push(view);\n  return views;\n};\nconst setForward = (views, view) => {\n  const index = views.indexOf(view);\n  if (index >= 0) {\n    views = views.filter(v => v.stackId !== view.stackId || v.id <= view.id);\n  } else {\n    views.push(view);\n  }\n  return views;\n};\nconst setBack = (views, view) => {\n  const index = views.indexOf(view);\n  if (index >= 0) {\n    return views.filter(v => v.stackId !== view.stackId || v.id <= view.id);\n  } else {\n    return setRoot(views, view);\n  }\n};\nconst getUrl = (router, activatedRoute) => {\n  const urlTree = router.createUrlTree(['.'], {\n    relativeTo: activatedRoute\n  });\n  return router.serializeUrl(urlTree);\n};\nconst isTabSwitch = (enteringView, leavingView) => {\n  if (!leavingView) {\n    return true;\n  }\n  return enteringView.stackId !== leavingView.stackId;\n};\nconst computeStackId = (prefixUrl, url) => {\n  if (!prefixUrl) {\n    return undefined;\n  }\n  const segments = toSegments(url);\n  for (let i = 0; i < segments.length; i++) {\n    if (i >= prefixUrl.length) {\n      return segments[i];\n    }\n    if (segments[i] !== prefixUrl[i]) {\n      return undefined;\n    }\n  }\n  return undefined;\n};\nconst toSegments = path => {\n  return path.split('/').map(s => s.trim()).filter(s => s !== '');\n};\nconst destroyView = view => {\n  if (view) {\n    view.ref.destroy();\n    view.unlistenEvents();\n  }\n};\n\n// TODO(FW-2827): types\nclass StackController {\n  constructor(tabsPrefix, containerEl, router, navCtrl, zone, location) {\n    _defineProperty(this, \"containerEl\", void 0);\n    _defineProperty(this, \"router\", void 0);\n    _defineProperty(this, \"navCtrl\", void 0);\n    _defineProperty(this, \"zone\", void 0);\n    _defineProperty(this, \"location\", void 0);\n    _defineProperty(this, \"views\", []);\n    _defineProperty(this, \"runningTask\", void 0);\n    _defineProperty(this, \"skipTransition\", false);\n    _defineProperty(this, \"tabsPrefix\", void 0);\n    _defineProperty(this, \"activeView\", void 0);\n    _defineProperty(this, \"nextId\", 0);\n    this.containerEl = containerEl;\n    this.router = router;\n    this.navCtrl = navCtrl;\n    this.zone = zone;\n    this.location = location;\n    this.tabsPrefix = tabsPrefix !== undefined ? toSegments(tabsPrefix) : undefined;\n  }\n  createView(ref, activatedRoute) {\n    var _ref$location;\n    const url = getUrl(this.router, activatedRoute);\n    const element = ref === null || ref === void 0 || (_ref$location = ref.location) === null || _ref$location === void 0 ? void 0 : _ref$location.nativeElement;\n    const unlistenEvents = bindLifecycleEvents(this.zone, ref.instance, element);\n    return {\n      id: this.nextId++,\n      stackId: computeStackId(this.tabsPrefix, url),\n      unlistenEvents,\n      element,\n      ref,\n      url\n    };\n  }\n  getExistingView(activatedRoute) {\n    const activatedUrlKey = getUrl(this.router, activatedRoute);\n    const view = this.views.find(vw => vw.url === activatedUrlKey);\n    if (view) {\n      view.ref.changeDetectorRef.reattach();\n    }\n    return view;\n  }\n  setActive(enteringView) {\n    var _router$navigations, _currentNavigation;\n    const consumeResult = this.navCtrl.consumeTransition();\n    let {\n      direction,\n      animation,\n      animationBuilder\n    } = consumeResult;\n    const leavingView = this.activeView;\n    const tabSwitch = isTabSwitch(enteringView, leavingView);\n    if (tabSwitch) {\n      direction = 'back';\n      animation = undefined;\n    }\n    const viewsSnapshot = this.views.slice();\n    let currentNavigation;\n    const router = this.router;\n    // Angular >= 7.2.0\n    if (router.getCurrentNavigation) {\n      currentNavigation = router.getCurrentNavigation();\n      // Angular < 7.2.0\n    } else if ((_router$navigations = router.navigations) !== null && _router$navigations !== void 0 && _router$navigations.value) {\n      currentNavigation = router.navigations.value;\n    }\n    /**\n     * If the navigation action\n     * sets `replaceUrl: true`\n     * then we need to make sure\n     * we remove the last item\n     * from our views stack\n     */\n    if ((_currentNavigation = currentNavigation) !== null && _currentNavigation !== void 0 && (_currentNavigation = _currentNavigation.extras) !== null && _currentNavigation !== void 0 && _currentNavigation.replaceUrl) {\n      if (this.views.length > 0) {\n        this.views.splice(-1, 1);\n      }\n    }\n    const reused = this.views.includes(enteringView);\n    const views = this.insertView(enteringView, direction);\n    // Trigger change detection before transition starts\n    // This will call ngOnInit() the first time too, just after the view\n    // was attached to the dom, but BEFORE the transition starts\n    if (!reused) {\n      enteringView.ref.changeDetectorRef.detectChanges();\n    }\n    /**\n     * If we are going back from a page that\n     * was presented using a custom animation\n     * we should default to using that\n     * unless the developer explicitly\n     * provided another animation.\n     */\n    const customAnimation = enteringView.animationBuilder;\n    if (animationBuilder === undefined && direction === 'back' && !tabSwitch && customAnimation !== undefined) {\n      animationBuilder = customAnimation;\n    }\n    /**\n     * Save any custom animation so that navigating\n     * back will use this custom animation by default.\n     */\n    if (leavingView) {\n      leavingView.animationBuilder = animationBuilder;\n    }\n    // Wait until previous transitions finish\n    return this.zone.runOutsideAngular(() => {\n      return this.wait(() => {\n        // disconnect leaving page from change detection to\n        // reduce jank during the page transition\n        if (leavingView) {\n          leavingView.ref.changeDetectorRef.detach();\n        }\n        // In case the enteringView is the same as the leavingPage we need to reattach()\n        enteringView.ref.changeDetectorRef.reattach();\n        return this.transition(enteringView, leavingView, animation, this.canGoBack(1), false, animationBuilder).then(() => cleanupAsync(enteringView, views, viewsSnapshot, this.location, this.zone)).then(() => ({\n          enteringView,\n          direction,\n          animation,\n          tabSwitch\n        }));\n      });\n    });\n  }\n  canGoBack(deep, stackId = this.getActiveStackId()) {\n    return this.getStack(stackId).length > deep;\n  }\n  pop(deep, stackId = this.getActiveStackId()) {\n    return this.zone.run(() => {\n      const views = this.getStack(stackId);\n      if (views.length <= deep) {\n        return Promise.resolve(false);\n      }\n      const view = views[views.length - deep - 1];\n      let url = view.url;\n      const viewSavedData = view.savedData;\n      if (viewSavedData) {\n        var _primaryOutlet$route;\n        const primaryOutlet = viewSavedData.get('primary');\n        if (primaryOutlet !== null && primaryOutlet !== void 0 && (_primaryOutlet$route = primaryOutlet.route) !== null && _primaryOutlet$route !== void 0 && (_primaryOutlet$route = _primaryOutlet$route._routerState) !== null && _primaryOutlet$route !== void 0 && _primaryOutlet$route.snapshot.url) {\n          url = primaryOutlet.route._routerState.snapshot.url;\n        }\n      }\n      const {\n        animationBuilder\n      } = this.navCtrl.consumeTransition();\n      return this.navCtrl.navigateBack(url, {\n        ...view.savedExtras,\n        animation: animationBuilder\n      }).then(() => true);\n    });\n  }\n  startBackTransition() {\n    const leavingView = this.activeView;\n    if (leavingView) {\n      const views = this.getStack(leavingView.stackId);\n      const enteringView = views[views.length - 2];\n      const customAnimation = enteringView.animationBuilder;\n      return this.wait(() => {\n        return this.transition(enteringView,\n        // entering view\n        leavingView,\n        // leaving view\n        'back', this.canGoBack(2), true, customAnimation);\n      });\n    }\n    return Promise.resolve();\n  }\n  endBackTransition(shouldComplete) {\n    if (shouldComplete) {\n      this.skipTransition = true;\n      this.pop(1);\n    } else if (this.activeView) {\n      cleanup(this.activeView, this.views, this.views, this.location, this.zone);\n    }\n  }\n  getLastUrl(stackId) {\n    const views = this.getStack(stackId);\n    return views.length > 0 ? views[views.length - 1] : undefined;\n  }\n  /**\n   * @internal\n   */\n  getRootUrl(stackId) {\n    const views = this.getStack(stackId);\n    return views.length > 0 ? views[0] : undefined;\n  }\n  getActiveStackId() {\n    return this.activeView ? this.activeView.stackId : undefined;\n  }\n  /**\n   * @internal\n   */\n  getActiveView() {\n    return this.activeView;\n  }\n  hasRunningTask() {\n    return this.runningTask !== undefined;\n  }\n  destroy() {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.containerEl = undefined;\n    this.views.forEach(destroyView);\n    this.activeView = undefined;\n    this.views = [];\n  }\n  getStack(stackId) {\n    return this.views.filter(v => v.stackId === stackId);\n  }\n  insertView(enteringView, direction) {\n    this.activeView = enteringView;\n    this.views = insertView(this.views, enteringView, direction);\n    return this.views.slice();\n  }\n  transition(enteringView, leavingView, direction, showGoBack, progressAnimation, animationBuilder) {\n    if (this.skipTransition) {\n      this.skipTransition = false;\n      return Promise.resolve(false);\n    }\n    if (leavingView === enteringView) {\n      return Promise.resolve(false);\n    }\n    const enteringEl = enteringView ? enteringView.element : undefined;\n    const leavingEl = leavingView ? leavingView.element : undefined;\n    const containerEl = this.containerEl;\n    if (enteringEl && enteringEl !== leavingEl) {\n      enteringEl.classList.add('ion-page');\n      enteringEl.classList.add('ion-page-invisible');\n      if (containerEl.commit) {\n        return containerEl.commit(enteringEl, leavingEl, {\n          duration: direction === undefined ? 0 : undefined,\n          direction,\n          showGoBack,\n          progressAnimation,\n          animationBuilder\n        });\n      }\n    }\n    return Promise.resolve(false);\n  }\n  wait(task) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.runningTask !== undefined) {\n        yield _this2.runningTask;\n        _this2.runningTask = undefined;\n      }\n      const promise = _this2.runningTask = task();\n      promise.finally(() => _this2.runningTask = undefined);\n      return promise;\n    })();\n  }\n}\nconst cleanupAsync = (activeRoute, views, viewsSnapshot, location, zone) => {\n  if (typeof requestAnimationFrame === 'function') {\n    return new Promise(resolve => {\n      requestAnimationFrame(() => {\n        cleanup(activeRoute, views, viewsSnapshot, location, zone);\n        resolve();\n      });\n    });\n  }\n  return Promise.resolve();\n};\nconst cleanup = (activeRoute, views, viewsSnapshot, location, zone) => {\n  /**\n   * Re-enter the Angular zone when destroying page components. This will allow\n   * lifecycle events (`ngOnDestroy`) to be run inside the Angular zone.\n   */\n  zone.run(() => viewsSnapshot.filter(view => !views.includes(view)).forEach(destroyView));\n  views.forEach(view => {\n    /**\n     * In the event that a user navigated multiple\n     * times in rapid succession, we want to make sure\n     * we don't pre-emptively detach a view while\n     * it is in mid-transition.\n     *\n     * In this instance we also do not care about query\n     * params or fragments as it will be the same view regardless\n     */\n    const locationWithoutParams = location.path().split('?')[0];\n    const locationWithoutFragment = locationWithoutParams.split('#')[0];\n    if (view !== activeRoute && view.url !== locationWithoutFragment) {\n      const element = view.element;\n      element.setAttribute('aria-hidden', 'true');\n      element.classList.add('ion-page-hidden');\n      view.ref.changeDetectorRef.detach();\n    }\n  });\n};\n\n// TODO(FW-2827): types\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\nlet IonRouterOutlet = /*#__PURE__*/(() => {\n  var _IonRouterOutlet;\n  class IonRouterOutlet {\n    /** @internal */\n    get activatedComponentRef() {\n      return this.activated;\n    }\n    set animation(animation) {\n      this.nativeEl.animation = animation;\n    }\n    set animated(animated) {\n      this.nativeEl.animated = animated;\n    }\n    set swipeGesture(swipe) {\n      this._swipeGesture = swipe;\n      this.nativeEl.swipeHandler = swipe ? {\n        canStart: () => this.stackCtrl.canGoBack(1) && !this.stackCtrl.hasRunningTask(),\n        onStart: () => this.stackCtrl.startBackTransition(),\n        onEnd: shouldContinue => this.stackCtrl.endBackTransition(shouldContinue)\n      } : undefined;\n    }\n    constructor(name, tabs, commonLocation, elementRef, router, zone, activatedRoute, parentOutlet) {\n      _defineProperty(this, \"parentOutlet\", void 0);\n      _defineProperty(this, \"nativeEl\", void 0);\n      _defineProperty(this, \"activatedView\", null);\n      _defineProperty(this, \"tabsPrefix\", void 0);\n      _defineProperty(this, \"_swipeGesture\", void 0);\n      _defineProperty(this, \"stackCtrl\", void 0);\n      // Maintain map of activated route proxies for each component instance\n      _defineProperty(this, \"proxyMap\", new WeakMap());\n      // Keep the latest activated route in a subject for the proxy routes to switch map to\n      _defineProperty(this, \"currentActivatedRoute$\", new BehaviorSubject(null));\n      _defineProperty(this, \"activated\", null);\n      _defineProperty(this, \"_activatedRoute\", null);\n      /**\n       * The name of the outlet\n       */\n      _defineProperty(this, \"name\", PRIMARY_OUTLET);\n      /** @internal */\n      _defineProperty(this, \"stackWillChange\", new EventEmitter());\n      /** @internal */\n      _defineProperty(this, \"stackDidChange\", new EventEmitter());\n      // eslint-disable-next-line @angular-eslint/no-output-rename\n      _defineProperty(this, \"activateEvents\", new EventEmitter());\n      // eslint-disable-next-line @angular-eslint/no-output-rename\n      _defineProperty(this, \"deactivateEvents\", new EventEmitter());\n      _defineProperty(this, \"parentContexts\", inject(ChildrenOutletContexts));\n      _defineProperty(this, \"location\", inject(ViewContainerRef));\n      _defineProperty(this, \"environmentInjector\", inject(EnvironmentInjector));\n      _defineProperty(this, \"inputBinder\", inject(INPUT_BINDER, {\n        optional: true\n      }));\n      /** @nodoc */\n      _defineProperty(this, \"supportsBindingToComponentInputs\", true);\n      // Ionic providers\n      _defineProperty(this, \"config\", inject(Config));\n      _defineProperty(this, \"navCtrl\", inject(NavController));\n      this.parentOutlet = parentOutlet;\n      this.nativeEl = elementRef.nativeElement;\n      this.name = name || PRIMARY_OUTLET;\n      this.tabsPrefix = tabs === 'true' ? getUrl(router, activatedRoute) : undefined;\n      this.stackCtrl = new StackController(this.tabsPrefix, this.nativeEl, router, this.navCtrl, zone, commonLocation);\n      this.parentContexts.onChildOutletCreated(this.name, this);\n    }\n    ngOnDestroy() {\n      var _this$inputBinder;\n      this.stackCtrl.destroy();\n      (_this$inputBinder = this.inputBinder) === null || _this$inputBinder === void 0 || _this$inputBinder.unsubscribeFromRouteData(this);\n    }\n    getContext() {\n      return this.parentContexts.getContext(this.name);\n    }\n    ngOnInit() {\n      this.initializeOutletWithName();\n    }\n    // Note: Ionic deviates from the Angular Router implementation here\n    initializeOutletWithName() {\n      if (!this.activated) {\n        // If the outlet was not instantiated at the time the route got activated we need to populate\n        // the outlet when it is initialized (ie inside a NgIf)\n        const context = this.getContext();\n        if (context !== null && context !== void 0 && context.route) {\n          this.activateWith(context.route, context.injector);\n        }\n      }\n      new Promise(resolve => componentOnReady(this.nativeEl, resolve)).then(() => {\n        if (this._swipeGesture === undefined) {\n          this.swipeGesture = this.config.getBoolean('swipeBackEnabled', this.nativeEl.mode === 'ios');\n        }\n      });\n    }\n    get isActivated() {\n      return !!this.activated;\n    }\n    get component() {\n      if (!this.activated) {\n        throw new Error('Outlet is not activated');\n      }\n      return this.activated.instance;\n    }\n    get activatedRoute() {\n      if (!this.activated) {\n        throw new Error('Outlet is not activated');\n      }\n      return this._activatedRoute;\n    }\n    get activatedRouteData() {\n      if (this._activatedRoute) {\n        return this._activatedRoute.snapshot.data;\n      }\n      return {};\n    }\n    /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     */\n    detach() {\n      throw new Error('incompatible reuse strategy');\n    }\n    /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    attach(_ref, _activatedRoute) {\n      throw new Error('incompatible reuse strategy');\n    }\n    deactivate() {\n      if (this.activated) {\n        if (this.activatedView) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const context = this.getContext();\n          this.activatedView.savedData = new Map(context.children['contexts']);\n          /**\n           * Angular v11.2.10 introduced a change\n           * where this route context is cleared out when\n           * a router-outlet is deactivated, However,\n           * we need this route information in order to\n           * return a user back to the correct tab when\n           * leaving and then going back to the tab context.\n           */\n          const primaryOutlet = this.activatedView.savedData.get('primary');\n          if (primaryOutlet && context.route) {\n            primaryOutlet.route = {\n              ...context.route\n            };\n          }\n          /**\n           * Ensure we are saving the NavigationExtras\n           * data otherwise it will be lost\n           */\n          this.activatedView.savedExtras = {};\n          if (context.route) {\n            const contextSnapshot = context.route.snapshot;\n            this.activatedView.savedExtras.queryParams = contextSnapshot.queryParams;\n            this.activatedView.savedExtras.fragment = contextSnapshot.fragment;\n          }\n        }\n        const c = this.component;\n        this.activatedView = null;\n        this.activated = null;\n        this._activatedRoute = null;\n        this.deactivateEvents.emit(c);\n      }\n    }\n    activateWith(activatedRoute, environmentInjector) {\n      var _this$inputBinder2;\n      if (this.isActivated) {\n        throw new Error('Cannot activate an already activated outlet');\n      }\n      this._activatedRoute = activatedRoute;\n      let cmpRef;\n      let enteringView = this.stackCtrl.getExistingView(activatedRoute);\n      if (enteringView) {\n        cmpRef = this.activated = enteringView.ref;\n        const saved = enteringView.savedData;\n        if (saved) {\n          // self-restore\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const context = this.getContext();\n          context.children['contexts'] = saved;\n        }\n        // Updated activated route proxy for this component\n        this.updateActivatedRouteProxy(cmpRef.instance, activatedRoute);\n      } else {\n        var _snapshot$routeConfig;\n        const snapshot = activatedRoute._futureSnapshot;\n        /**\n         * Angular 14 introduces a new `loadComponent` property to the route config.\n         * This function will assign a `component` property to the route snapshot.\n         * We check for the presence of this property to determine if the route is\n         * using standalone components.\n         */\n        const childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n        // We create an activated route proxy object that will maintain future updates for this component\n        // over its lifecycle in the stack.\n        const component$ = new BehaviorSubject(null);\n        const activatedRouteProxy = this.createActivatedRouteProxy(component$, activatedRoute);\n        const injector = new OutletInjector(activatedRouteProxy, childContexts, this.location.injector);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const component = (_snapshot$routeConfig = snapshot.routeConfig.component) !== null && _snapshot$routeConfig !== void 0 ? _snapshot$routeConfig : snapshot.component;\n        /**\n         * View components need to be added as a child of ion-router-outlet\n         * for page transitions and swipe to go back.\n         * However, createComponent mounts components as siblings of the\n         * ViewContainerRef. As a result, outletContent must reference\n         * an ng-container inside of ion-router-outlet and not\n         * ion-router-outlet itself.\n         */\n        cmpRef = this.activated = this.outletContent.createComponent(component, {\n          index: this.outletContent.length,\n          injector,\n          environmentInjector: environmentInjector !== null && environmentInjector !== void 0 ? environmentInjector : this.environmentInjector\n        });\n        // Once the component is created we can push it to our local subject supplied to the proxy\n        component$.next(cmpRef.instance);\n        // Calling `markForCheck` to make sure we will run the change detection when the\n        // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n        /**\n         * At this point this.activated has been set earlier\n         * in this function, so it is guaranteed to be non-null.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        enteringView = this.stackCtrl.createView(this.activated, activatedRoute);\n        // Store references to the proxy by component\n        this.proxyMap.set(cmpRef.instance, activatedRouteProxy);\n        this.currentActivatedRoute$.next({\n          component: cmpRef.instance,\n          activatedRoute\n        });\n      }\n      (_this$inputBinder2 = this.inputBinder) === null || _this$inputBinder2 === void 0 || _this$inputBinder2.bindActivatedRouteToOutletComponent(this);\n      this.activatedView = enteringView;\n      /**\n       * The top outlet is set prior to the entering view's transition completing,\n       * so that when we have nested outlets (e.g. ion-tabs inside an ion-router-outlet),\n       * the tabs outlet will be assigned as the top outlet when a view inside tabs is\n       * activated.\n       *\n       * In this scenario, activeWith is called for both the tabs and the root router outlet.\n       * To avoid a race condition, we assign the top outlet synchronously.\n       */\n      this.navCtrl.setTopOutlet(this);\n      const leavingView = this.stackCtrl.getActiveView();\n      this.stackWillChange.emit({\n        enteringView,\n        tabSwitch: isTabSwitch(enteringView, leavingView)\n      });\n      this.stackCtrl.setActive(enteringView).then(data => {\n        this.activateEvents.emit(cmpRef.instance);\n        this.stackDidChange.emit(data);\n      });\n    }\n    /**\n     * Returns `true` if there are pages in the stack to go back.\n     */\n    canGoBack(deep = 1, stackId) {\n      return this.stackCtrl.canGoBack(deep, stackId);\n    }\n    /**\n     * Resolves to `true` if it the outlet was able to sucessfully pop the last N pages.\n     */\n    pop(deep = 1, stackId) {\n      return this.stackCtrl.pop(deep, stackId);\n    }\n    /**\n     * Returns the URL of the active page of each stack.\n     */\n    getLastUrl(stackId) {\n      const active = this.stackCtrl.getLastUrl(stackId);\n      return active ? active.url : undefined;\n    }\n    /**\n     * Returns the RouteView of the active page of each stack.\n     * @internal\n     */\n    getLastRouteView(stackId) {\n      return this.stackCtrl.getLastUrl(stackId);\n    }\n    /**\n     * Returns the root view in the tab stack.\n     * @internal\n     */\n    getRootView(stackId) {\n      return this.stackCtrl.getRootUrl(stackId);\n    }\n    /**\n     * Returns the active stack ID. In the context of ion-tabs, it means the active tab.\n     */\n    getActiveStackId() {\n      return this.stackCtrl.getActiveStackId();\n    }\n    /**\n     * Since the activated route can change over the life time of a component in an ion router outlet, we create\n     * a proxy so that we can update the values over time as a user navigates back to components already in the stack.\n     */\n    createActivatedRouteProxy(component$, activatedRoute) {\n      const proxy = new ActivatedRoute();\n      proxy._futureSnapshot = activatedRoute._futureSnapshot;\n      proxy._routerState = activatedRoute._routerState;\n      proxy.snapshot = activatedRoute.snapshot;\n      proxy.outlet = activatedRoute.outlet;\n      proxy.component = activatedRoute.component;\n      // Setup wrappers for the observables so consumers don't have to worry about switching to new observables as the state updates\n      proxy._paramMap = this.proxyObservable(component$, 'paramMap');\n      proxy._queryParamMap = this.proxyObservable(component$, 'queryParamMap');\n      proxy.url = this.proxyObservable(component$, 'url');\n      proxy.params = this.proxyObservable(component$, 'params');\n      proxy.queryParams = this.proxyObservable(component$, 'queryParams');\n      proxy.fragment = this.proxyObservable(component$, 'fragment');\n      proxy.data = this.proxyObservable(component$, 'data');\n      return proxy;\n    }\n    /**\n     * Create a wrapped observable that will switch to the latest activated route matched by the given component\n     */\n    proxyObservable(component$, path) {\n      return component$.pipe(\n      // First wait until the component instance is pushed\n      filter(component => !!component), switchMap(component => this.currentActivatedRoute$.pipe(filter(current => current !== null && current.component === component), switchMap(current => current && current.activatedRoute[path]), distinctUntilChanged())));\n    }\n    /**\n     * Updates the activated route proxy for the given component to the new incoming router state\n     */\n    updateActivatedRouteProxy(component, activatedRoute) {\n      const proxy = this.proxyMap.get(component);\n      if (!proxy) {\n        throw new Error(`Could not find activated route proxy for view`);\n      }\n      proxy._futureSnapshot = activatedRoute._futureSnapshot;\n      proxy._routerState = activatedRoute._routerState;\n      proxy.snapshot = activatedRoute.snapshot;\n      proxy.outlet = activatedRoute.outlet;\n      proxy.component = activatedRoute.component;\n      this.currentActivatedRoute$.next({\n        component,\n        activatedRoute\n      });\n    }\n    /** @nocollapse */\n  }\n  _IonRouterOutlet = IonRouterOutlet;\n  _defineProperty(IonRouterOutlet, \"\\u0275fac\", function _IonRouterOutlet_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _IonRouterOutlet)(i0.ɵɵinjectAttribute('name'), i0.ɵɵinjectAttribute('tabs'), i0.ɵɵdirectiveInject(i1.Location), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i3.Router), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i3.ActivatedRoute), i0.ɵɵdirectiveInject(_IonRouterOutlet, 12));\n  });\n  /** @nocollapse */\n  _defineProperty(IonRouterOutlet, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _IonRouterOutlet,\n    selectors: [[\"ion-router-outlet\"]],\n    inputs: {\n      animated: \"animated\",\n      animation: \"animation\",\n      mode: \"mode\",\n      swipeGesture: \"swipeGesture\",\n      name: \"name\"\n    },\n    outputs: {\n      stackWillChange: \"stackWillChange\",\n      stackDidChange: \"stackDidChange\",\n      activateEvents: \"activate\",\n      deactivateEvents: \"deactivate\"\n    },\n    exportAs: [\"outlet\"]\n  }));\n  return IonRouterOutlet;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass OutletInjector {\n  constructor(route, childContexts, parent) {\n    _defineProperty(this, \"route\", void 0);\n    _defineProperty(this, \"childContexts\", void 0);\n    _defineProperty(this, \"parent\", void 0);\n    this.route = route;\n    this.childContexts = childContexts;\n    this.parent = parent;\n  }\n  get(token, notFoundValue) {\n    if (token === ActivatedRoute) {\n      return this.route;\n    }\n    if (token === ChildrenOutletContexts) {\n      return this.childContexts;\n    }\n    return this.parent.get(token, notFoundValue);\n  }\n}\n// TODO: FW-4785 - Remove this once Angular 15 support is dropped\nconst INPUT_BINDER = new InjectionToken('');\n/**\n * Injectable used as a tree-shakable provider for opting in to binding router data to component\n * inputs.\n *\n * The RouterOutlet registers itself with this service when an `ActivatedRoute` is attached or\n * activated. When this happens, the service subscribes to the `ActivatedRoute` observables (params,\n * queryParams, data) and sets the inputs of the component using `ComponentRef.setInput`.\n * Importantly, when an input does not have an item in the route data with a matching key, this\n * input is set to `undefined`. If it were not done this way, the previous information would be\n * retained if the data got removed from the route (i.e. if a query parameter is removed).\n *\n * The `RouterOutlet` should unregister itself when destroyed via `unsubscribeFromRouteData` so that\n * the subscriptions are cleaned up.\n */\nlet RoutedComponentInputBinder = /*#__PURE__*/(() => {\n  var _RoutedComponentInputBinder;\n  class RoutedComponentInputBinder {\n    constructor() {\n      _defineProperty(this, \"outletDataSubscriptions\", new Map());\n    }\n    bindActivatedRouteToOutletComponent(outlet) {\n      this.unsubscribeFromRouteData(outlet);\n      this.subscribeToRouteData(outlet);\n    }\n    unsubscribeFromRouteData(outlet) {\n      var _this$outletDataSubsc;\n      (_this$outletDataSubsc = this.outletDataSubscriptions.get(outlet)) === null || _this$outletDataSubsc === void 0 || _this$outletDataSubsc.unsubscribe();\n      this.outletDataSubscriptions.delete(outlet);\n    }\n    subscribeToRouteData(outlet) {\n      const {\n        activatedRoute\n      } = outlet;\n      const dataSubscription = combineLatest([activatedRoute.queryParams, activatedRoute.params, activatedRoute.data]).pipe(switchMap(([queryParams, params, data], index) => {\n        data = {\n          ...queryParams,\n          ...params,\n          ...data\n        };\n        // Get the first result from the data subscription synchronously so it's available to\n        // the component as soon as possible (and doesn't require a second change detection).\n        if (index === 0) {\n          return of(data);\n        }\n        // Promise.resolve is used to avoid synchronously writing the wrong data when\n        // two of the Observables in the `combineLatest` stream emit one after\n        // another.\n        return Promise.resolve(data);\n      })).subscribe(data => {\n        // Outlet may have been deactivated or changed names to be associated with a different\n        // route\n        if (!outlet.isActivated || !outlet.activatedComponentRef || outlet.activatedRoute !== activatedRoute || activatedRoute.component === null) {\n          this.unsubscribeFromRouteData(outlet);\n          return;\n        }\n        const mirror = reflectComponentType(activatedRoute.component);\n        if (!mirror) {\n          this.unsubscribeFromRouteData(outlet);\n          return;\n        }\n        for (const {\n          templateName\n        } of mirror.inputs) {\n          outlet.activatedComponentRef.setInput(templateName, data[templateName]);\n        }\n      });\n      this.outletDataSubscriptions.set(outlet, dataSubscription);\n    }\n    /** @nocollapse */\n  }\n  _RoutedComponentInputBinder = RoutedComponentInputBinder;\n  _defineProperty(RoutedComponentInputBinder, \"\\u0275fac\", function _RoutedComponentInputBinder_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RoutedComponentInputBinder)();\n  });\n  /** @nocollapse */\n  _defineProperty(RoutedComponentInputBinder, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _RoutedComponentInputBinder,\n    factory: _RoutedComponentInputBinder.ɵfac\n  }));\n  return RoutedComponentInputBinder;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst provideComponentInputBinding = () => {\n  return {\n    provide: INPUT_BINDER,\n    useFactory: componentInputBindingFactory,\n    deps: [Router]\n  };\n};\nfunction componentInputBindingFactory(router) {\n  /**\n   * We cast the router to any here, since the componentInputBindingEnabled\n   * property is not available until Angular v16.\n   */\n  if (router !== null && router !== void 0 && router.componentInputBindingEnabled) {\n    return new RoutedComponentInputBinder();\n  }\n  return null;\n}\nconst BACK_BUTTON_INPUTS = ['color', 'defaultHref', 'disabled', 'icon', 'mode', 'routerAnimation', 'text', 'type'];\nlet IonBackButton = /*#__PURE__*/(() => {\n  var _IonBackButton;\n  let IonBackButton = (_IonBackButton = class IonBackButton {\n    constructor(routerOutlet, navCtrl, config, r, z, c) {\n      _defineProperty(this, \"routerOutlet\", void 0);\n      _defineProperty(this, \"navCtrl\", void 0);\n      _defineProperty(this, \"config\", void 0);\n      _defineProperty(this, \"r\", void 0);\n      _defineProperty(this, \"z\", void 0);\n      _defineProperty(this, \"el\", void 0);\n      this.routerOutlet = routerOutlet;\n      this.navCtrl = navCtrl;\n      this.config = config;\n      this.r = r;\n      this.z = z;\n      c.detach();\n      this.el = this.r.nativeElement;\n    }\n    /**\n     * @internal\n     */\n    onClick(ev) {\n      var _this$routerOutlet;\n      const defaultHref = this.defaultHref || this.config.get('backButtonDefaultHref');\n      if ((_this$routerOutlet = this.routerOutlet) !== null && _this$routerOutlet !== void 0 && _this$routerOutlet.canGoBack()) {\n        this.navCtrl.setDirection('back', undefined, undefined, this.routerAnimation);\n        this.routerOutlet.pop();\n        ev.preventDefault();\n      } else if (defaultHref != null) {\n        this.navCtrl.navigateBack(defaultHref, {\n          animation: this.routerAnimation\n        });\n        ev.preventDefault();\n      }\n    }\n    /** @nocollapse */\n  }, _defineProperty(_IonBackButton, \"\\u0275fac\", function _IonBackButton_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _IonBackButton)(i0.ɵɵdirectiveInject(IonRouterOutlet, 8), i0.ɵɵdirectiveInject(NavController), i0.ɵɵdirectiveInject(Config), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  }), _defineProperty(_IonBackButton, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _IonBackButton,\n    hostBindings: function _IonBackButton_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function _IonBackButton_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n    },\n    inputs: {\n      color: \"color\",\n      defaultHref: \"defaultHref\",\n      disabled: \"disabled\",\n      icon: \"icon\",\n      mode: \"mode\",\n      routerAnimation: \"routerAnimation\",\n      text: \"text\",\n      type: \"type\"\n    }\n  })), _IonBackButton);\n  IonBackButton = __decorate([ProxyCmp({\n    inputs: BACK_BUTTON_INPUTS\n  })], IonBackButton);\n  return IonBackButton;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Adds support for Ionic routing directions and animations to the base Angular router link directive.\n *\n * When the router link is clicked, the directive will assign the direction and\n * animation so that the routing integration will transition correctly.\n */\nlet RouterLinkDelegateDirective = /*#__PURE__*/(() => {\n  var _RouterLinkDelegateDirective;\n  class RouterLinkDelegateDirective {\n    constructor(locationStrategy, navCtrl, elementRef, router, routerLink) {\n      _defineProperty(this, \"locationStrategy\", void 0);\n      _defineProperty(this, \"navCtrl\", void 0);\n      _defineProperty(this, \"elementRef\", void 0);\n      _defineProperty(this, \"router\", void 0);\n      _defineProperty(this, \"routerLink\", void 0);\n      _defineProperty(this, \"routerDirection\", 'forward');\n      _defineProperty(this, \"routerAnimation\", void 0);\n      this.locationStrategy = locationStrategy;\n      this.navCtrl = navCtrl;\n      this.elementRef = elementRef;\n      this.router = router;\n      this.routerLink = routerLink;\n    }\n    ngOnInit() {\n      this.updateTargetUrlAndHref();\n      this.updateTabindex();\n    }\n    ngOnChanges() {\n      this.updateTargetUrlAndHref();\n    }\n    /**\n     * The `tabindex` is set to `0` by default on the host element when\n     * the `routerLink` directive is used. This causes issues with Ionic\n     * components that wrap an `a` or `button` element, such as `ion-item`.\n     * See issue https://github.com/angular/angular/issues/28345\n     *\n     * This method removes the `tabindex` attribute from the host element\n     * to allow the Ionic component to manage the focus state correctly.\n     */\n    updateTabindex() {\n      // Ionic components that render a native anchor or button element\n      const ionicComponents = ['ION-BACK-BUTTON', 'ION-BREADCRUMB', 'ION-BUTTON', 'ION-CARD', 'ION-FAB-BUTTON', 'ION-ITEM', 'ION-ITEM-OPTION', 'ION-MENU-BUTTON', 'ION-SEGMENT-BUTTON', 'ION-TAB-BUTTON'];\n      const hostElement = this.elementRef.nativeElement;\n      if (ionicComponents.includes(hostElement.tagName)) {\n        if (hostElement.getAttribute('tabindex') === '0') {\n          hostElement.removeAttribute('tabindex');\n        }\n      }\n    }\n    updateTargetUrlAndHref() {\n      var _this$routerLink;\n      if ((_this$routerLink = this.routerLink) !== null && _this$routerLink !== void 0 && _this$routerLink.urlTree) {\n        const href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.routerLink.urlTree));\n        this.elementRef.nativeElement.href = href;\n      }\n    }\n    /**\n     * @internal\n     */\n    onClick(ev) {\n      this.navCtrl.setDirection(this.routerDirection, undefined, undefined, this.routerAnimation);\n      /**\n       * This prevents the browser from\n       * performing a page reload when pressing\n       * an Ionic component with routerLink.\n       * The page reload interferes with routing\n       * and causes ion-back-button to disappear\n       * since the local history is wiped on reload.\n       */\n      ev.preventDefault();\n    }\n    /** @nocollapse */\n  }\n  _RouterLinkDelegateDirective = RouterLinkDelegateDirective;\n  _defineProperty(RouterLinkDelegateDirective, \"\\u0275fac\", function _RouterLinkDelegateDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RouterLinkDelegateDirective)(i0.ɵɵdirectiveInject(i1.LocationStrategy), i0.ɵɵdirectiveInject(NavController), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i3.Router), i0.ɵɵdirectiveInject(i3.RouterLink, 8));\n  });\n  /** @nocollapse */\n  _defineProperty(RouterLinkDelegateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _RouterLinkDelegateDirective,\n    selectors: [[\"\", \"routerLink\", \"\", 5, \"a\", 5, \"area\"]],\n    hostBindings: function _RouterLinkDelegateDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function _RouterLinkDelegateDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n    },\n    inputs: {\n      routerDirection: \"routerDirection\",\n      routerAnimation: \"routerAnimation\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  }));\n  return RouterLinkDelegateDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RouterLinkWithHrefDelegateDirective = /*#__PURE__*/(() => {\n  var _RouterLinkWithHrefDelegateDirective;\n  class RouterLinkWithHrefDelegateDirective {\n    constructor(locationStrategy, navCtrl, elementRef, router, routerLink) {\n      _defineProperty(this, \"locationStrategy\", void 0);\n      _defineProperty(this, \"navCtrl\", void 0);\n      _defineProperty(this, \"elementRef\", void 0);\n      _defineProperty(this, \"router\", void 0);\n      _defineProperty(this, \"routerLink\", void 0);\n      _defineProperty(this, \"routerDirection\", 'forward');\n      _defineProperty(this, \"routerAnimation\", void 0);\n      this.locationStrategy = locationStrategy;\n      this.navCtrl = navCtrl;\n      this.elementRef = elementRef;\n      this.router = router;\n      this.routerLink = routerLink;\n    }\n    ngOnInit() {\n      this.updateTargetUrlAndHref();\n    }\n    ngOnChanges() {\n      this.updateTargetUrlAndHref();\n    }\n    updateTargetUrlAndHref() {\n      var _this$routerLink2;\n      if ((_this$routerLink2 = this.routerLink) !== null && _this$routerLink2 !== void 0 && _this$routerLink2.urlTree) {\n        const href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.routerLink.urlTree));\n        this.elementRef.nativeElement.href = href;\n      }\n    }\n    /**\n     * @internal\n     */\n    onClick() {\n      this.navCtrl.setDirection(this.routerDirection, undefined, undefined, this.routerAnimation);\n    }\n    /** @nocollapse */\n  }\n  _RouterLinkWithHrefDelegateDirective = RouterLinkWithHrefDelegateDirective;\n  _defineProperty(RouterLinkWithHrefDelegateDirective, \"\\u0275fac\", function _RouterLinkWithHrefDelegateDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RouterLinkWithHrefDelegateDirective)(i0.ɵɵdirectiveInject(i1.LocationStrategy), i0.ɵɵdirectiveInject(NavController), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i3.Router), i0.ɵɵdirectiveInject(i3.RouterLink, 8));\n  });\n  /** @nocollapse */\n  _defineProperty(RouterLinkWithHrefDelegateDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _RouterLinkWithHrefDelegateDirective,\n    selectors: [[\"a\", \"routerLink\", \"\"], [\"area\", \"routerLink\", \"\"]],\n    hostBindings: function _RouterLinkWithHrefDelegateDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function _RouterLinkWithHrefDelegateDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n    },\n    inputs: {\n      routerDirection: \"routerDirection\",\n      routerAnimation: \"routerAnimation\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  }));\n  return RouterLinkWithHrefDelegateDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NAV_INPUTS = ['animated', 'animation', 'root', 'rootParams', 'swipeGesture'];\nconst NAV_METHODS = ['push', 'insert', 'insertPages', 'pop', 'popTo', 'popToRoot', 'removeIndex', 'setRoot', 'setPages', 'getActive', 'getByIndex', 'canGoBack', 'getPrevious'];\nlet IonNav = /*#__PURE__*/(() => {\n  var _IonNav;\n  let IonNav = (_IonNav = class IonNav {\n    constructor(ref, environmentInjector, injector, angularDelegate, z, c) {\n      _defineProperty(this, \"z\", void 0);\n      _defineProperty(this, \"el\", void 0);\n      this.z = z;\n      c.detach();\n      this.el = ref.nativeElement;\n      ref.nativeElement.delegate = angularDelegate.create(environmentInjector, injector);\n      proxyOutputs(this, this.el, ['ionNavDidChange', 'ionNavWillChange']);\n    }\n    /** @nocollapse */\n  }, _defineProperty(_IonNav, \"\\u0275fac\", function _IonNav_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _IonNav)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.EnvironmentInjector), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(AngularDelegate), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  }), _defineProperty(_IonNav, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _IonNav,\n    inputs: {\n      animated: \"animated\",\n      animation: \"animation\",\n      root: \"root\",\n      rootParams: \"rootParams\",\n      swipeGesture: \"swipeGesture\"\n    }\n  })), _IonNav);\n  IonNav = __decorate([ProxyCmp({\n    inputs: NAV_INPUTS,\n    methods: NAV_METHODS\n  })], IonNav);\n  return IonNav;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\nlet IonTabs = /*#__PURE__*/(() => {\n  var _IonTabs;\n  class IonTabs {\n    constructor(navCtrl) {\n      _defineProperty(this, \"navCtrl\", void 0);\n      _defineProperty(this, \"tabsInner\", void 0);\n      /**\n       * Emitted before the tab view is changed.\n       */\n      _defineProperty(this, \"ionTabsWillChange\", new EventEmitter());\n      /**\n       * Emitted after the tab view is changed.\n       */\n      _defineProperty(this, \"ionTabsDidChange\", new EventEmitter());\n      _defineProperty(this, \"tabBarSlot\", 'bottom');\n      _defineProperty(this, \"hasTab\", false);\n      _defineProperty(this, \"selectedTab\", void 0);\n      _defineProperty(this, \"leavingTab\", void 0);\n      this.navCtrl = navCtrl;\n    }\n    ngAfterViewInit() {\n      /**\n       * Developers must pass at least one ion-tab\n       * inside of ion-tabs if they want to use a\n       * basic tab-based navigation without the\n       * history stack or URL updates associated\n       * with the router.\n       */\n      const firstTab = this.tabs.length > 0 ? this.tabs.first : undefined;\n      if (firstTab) {\n        this.hasTab = true;\n        this.setActiveTab(firstTab.tab);\n        this.tabSwitch();\n      }\n    }\n    ngAfterContentInit() {\n      this.detectSlotChanges();\n    }\n    ngAfterContentChecked() {\n      this.detectSlotChanges();\n    }\n    /**\n     * @internal\n     */\n    onStackWillChange({\n      enteringView,\n      tabSwitch\n    }) {\n      const stackId = enteringView.stackId;\n      if (tabSwitch && stackId !== undefined) {\n        this.ionTabsWillChange.emit({\n          tab: stackId\n        });\n      }\n    }\n    /**\n     * @internal\n     */\n    onStackDidChange({\n      enteringView,\n      tabSwitch\n    }) {\n      const stackId = enteringView.stackId;\n      if (tabSwitch && stackId !== undefined) {\n        if (this.tabBar) {\n          this.tabBar.selectedTab = stackId;\n        }\n        this.ionTabsDidChange.emit({\n          tab: stackId\n        });\n      }\n    }\n    /**\n     * When a tab button is clicked, there are several scenarios:\n     * 1. If the selected tab is currently active (the tab button has been clicked\n     *    again), then it should go to the root view for that tab.\n     *\n     *   a. Get the saved root view from the router outlet. If the saved root view\n     *      matches the tabRootUrl, set the route view to this view including the\n     *      navigation extras.\n     *   b. If the saved root view from the router outlet does\n     *      not match, navigate to the tabRootUrl. No navigation extras are\n     *      included.\n     *\n     * 2. If the current tab tab is not currently selected, get the last route\n     *    view from the router outlet.\n     *\n     *   a. If the last route view exists, navigate to that view including any\n     *      navigation extras\n     *   b. If the last route view doesn't exist, then navigate\n     *      to the default tabRootUrl\n     */\n    select(tabOrEvent) {\n      const isTabString = typeof tabOrEvent === 'string';\n      const tab = isTabString ? tabOrEvent : tabOrEvent.detail.tab;\n      /**\n       * If the tabs are not using the router, then\n       * the tab switch logic is handled by the tabs\n       * component itself.\n       */\n      if (this.hasTab) {\n        this.setActiveTab(tab);\n        this.tabSwitch();\n        return;\n      }\n      const alreadySelected = this.outlet.getActiveStackId() === tab;\n      const tabRootUrl = `${this.outlet.tabsPrefix}/${tab}`;\n      /**\n       * If this is a nested tab, prevent the event\n       * from bubbling otherwise the outer tabs\n       * will respond to this event too, causing\n       * the app to get directed to the wrong place.\n       */\n      if (!isTabString) {\n        tabOrEvent.stopPropagation();\n      }\n      if (alreadySelected) {\n        const activeStackId = this.outlet.getActiveStackId();\n        const activeView = this.outlet.getLastRouteView(activeStackId);\n        // If on root tab, do not navigate to root tab again\n        if ((activeView === null || activeView === void 0 ? void 0 : activeView.url) === tabRootUrl) {\n          return;\n        }\n        const rootView = this.outlet.getRootView(tab);\n        const navigationExtras = rootView && tabRootUrl === rootView.url && rootView.savedExtras;\n        return this.navCtrl.navigateRoot(tabRootUrl, {\n          ...navigationExtras,\n          animated: true,\n          animationDirection: 'back'\n        });\n      } else {\n        const lastRoute = this.outlet.getLastRouteView(tab);\n        /**\n         * If there is a lastRoute, goto that, otherwise goto the fallback url of the\n         * selected tab\n         */\n        const url = (lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.url) || tabRootUrl;\n        const navigationExtras = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.savedExtras;\n        return this.navCtrl.navigateRoot(url, {\n          ...navigationExtras,\n          animated: true,\n          animationDirection: 'back'\n        });\n      }\n    }\n    setActiveTab(tab) {\n      const tabs = this.tabs;\n      const selectedTab = tabs.find(t => t.tab === tab);\n      if (!selectedTab) {\n        console.error(`[Ionic Error]: Tab with id: \"${tab}\" does not exist`);\n        return;\n      }\n      this.leavingTab = this.selectedTab;\n      this.selectedTab = selectedTab;\n      this.ionTabsWillChange.emit({\n        tab\n      });\n      selectedTab.el.active = true;\n    }\n    tabSwitch() {\n      const {\n        selectedTab,\n        leavingTab\n      } = this;\n      if (this.tabBar && selectedTab) {\n        this.tabBar.selectedTab = selectedTab.tab;\n      }\n      if ((leavingTab === null || leavingTab === void 0 ? void 0 : leavingTab.tab) !== (selectedTab === null || selectedTab === void 0 ? void 0 : selectedTab.tab)) {\n        if (leavingTab !== null && leavingTab !== void 0 && leavingTab.el) {\n          leavingTab.el.active = false;\n        }\n      }\n      if (selectedTab) {\n        this.ionTabsDidChange.emit({\n          tab: selectedTab.tab\n        });\n      }\n    }\n    getSelected() {\n      if (this.hasTab) {\n        var _this$selectedTab;\n        return (_this$selectedTab = this.selectedTab) === null || _this$selectedTab === void 0 ? void 0 : _this$selectedTab.tab;\n      }\n      return this.outlet.getActiveStackId();\n    }\n    /**\n     * Detects changes to the slot attribute of the tab bar.\n     *\n     * If the slot attribute has changed, then the tab bar\n     * should be relocated to the new slot position.\n     */\n    detectSlotChanges() {\n      this.tabBars.forEach(tabBar => {\n        // el is a protected attribute from the generated component wrapper\n        const currentSlot = tabBar.el.getAttribute('slot');\n        if (currentSlot !== this.tabBarSlot) {\n          this.tabBarSlot = currentSlot;\n          this.relocateTabBar();\n        }\n      });\n    }\n    /**\n     * Relocates the tab bar to the new slot position.\n     */\n    relocateTabBar() {\n      /**\n       * `el` is a protected attribute from the generated component wrapper.\n       * To avoid having to manually create the wrapper for tab bar, we\n       * cast the tab bar to any and access the protected attribute.\n       */\n      const tabBar = this.tabBar.el;\n      if (this.tabBarSlot === 'top') {\n        /**\n         * A tab bar with a slot of \"top\" should be inserted\n         * at the top of the container.\n         */\n        this.tabsInner.nativeElement.before(tabBar);\n      } else {\n        /**\n         * A tab bar with a slot of \"bottom\" or without a slot\n         * should be inserted at the end of the container.\n         */\n        this.tabsInner.nativeElement.after(tabBar);\n      }\n    }\n    /** @nocollapse */\n  }\n  _IonTabs = IonTabs;\n  _defineProperty(IonTabs, \"\\u0275fac\", function _IonTabs_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _IonTabs)(i0.ɵɵdirectiveInject(NavController));\n  });\n  /** @nocollapse */\n  _defineProperty(IonTabs, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _IonTabs,\n    selectors: [[\"ion-tabs\"]],\n    viewQuery: function _IonTabs_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7, ElementRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tabsInner = _t.first);\n      }\n    },\n    hostBindings: function _IonTabs_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"ionTabButtonClick\", function _IonTabs_ionTabButtonClick_HostBindingHandler($event) {\n          return ctx.select($event);\n        });\n      }\n    },\n    outputs: {\n      ionTabsWillChange: \"ionTabsWillChange\",\n      ionTabsDidChange: \"ionTabsDidChange\"\n    }\n  }));\n  return IonTabs;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst raf = h => {\n  if (typeof __zone_symbol__requestAnimationFrame === 'function') {\n    return __zone_symbol__requestAnimationFrame(h);\n  }\n  if (typeof requestAnimationFrame === 'function') {\n    return requestAnimationFrame(h);\n  }\n  return setTimeout(h);\n};\n\n// TODO(FW-2827): types\nlet ValueAccessor = /*#__PURE__*/(() => {\n  var _ValueAccessor;\n  class ValueAccessor {\n    constructor(injector, elementRef) {\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"elementRef\", void 0);\n      _defineProperty(this, \"onChange\", () => {\n        /**/\n      });\n      _defineProperty(this, \"onTouched\", () => {\n        /**/\n      });\n      _defineProperty(this, \"lastValue\", void 0);\n      _defineProperty(this, \"statusChanges\", void 0);\n      this.injector = injector;\n      this.elementRef = elementRef;\n    }\n    writeValue(value) {\n      this.elementRef.nativeElement.value = this.lastValue = value;\n      setIonicClasses(this.elementRef);\n    }\n    /**\n     * Notifies the ControlValueAccessor of a change in the value of the control.\n     *\n     * This is called by each of the ValueAccessor directives when we want to update\n     * the status and validity of the form control. For example with text components this\n     * is called when the ionInput event is fired. For select components this is called\n     * when the ionChange event is fired.\n     *\n     * This also updates the Ionic form status classes on the element.\n     *\n     * @param el The component element.\n     * @param value The new value of the control.\n     */\n    handleValueChange(el, value) {\n      if (el === this.elementRef.nativeElement) {\n        if (value !== this.lastValue) {\n          this.lastValue = value;\n          this.onChange(value);\n        }\n        setIonicClasses(this.elementRef);\n      }\n    }\n    _handleBlurEvent(el) {\n      if (el === this.elementRef.nativeElement) {\n        this.onTouched();\n        setIonicClasses(this.elementRef);\n      }\n    }\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    setDisabledState(isDisabled) {\n      this.elementRef.nativeElement.disabled = isDisabled;\n    }\n    ngOnDestroy() {\n      if (this.statusChanges) {\n        this.statusChanges.unsubscribe();\n      }\n    }\n    ngAfterViewInit() {\n      let ngControl;\n      try {\n        ngControl = this.injector.get(NgControl);\n      } catch {\n        /* No FormControl or ngModel binding */\n      }\n      if (!ngControl) {\n        return;\n      }\n      // Listen for changes in validity, disabled, or pending states\n      if (ngControl.statusChanges) {\n        this.statusChanges = ngControl.statusChanges.subscribe(() => setIonicClasses(this.elementRef));\n      }\n      /**\n       * TODO FW-2787: Remove this in favor of https://github.com/angular/angular/issues/10887\n       * whenever it is implemented.\n       */\n      const formControl = ngControl.control;\n      if (formControl) {\n        const methodsToPatch = ['markAsTouched', 'markAllAsTouched', 'markAsUntouched', 'markAsDirty', 'markAsPristine'];\n        methodsToPatch.forEach(method => {\n          if (typeof formControl[method] !== 'undefined') {\n            const oldFn = formControl[method].bind(formControl);\n            formControl[method] = (...params) => {\n              oldFn(...params);\n              setIonicClasses(this.elementRef);\n            };\n          }\n        });\n      }\n    }\n    /** @nocollapse */\n  }\n  _ValueAccessor = ValueAccessor;\n  _defineProperty(ValueAccessor, \"\\u0275fac\", function _ValueAccessor_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _ValueAccessor)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef));\n  });\n  /** @nocollapse */\n  _defineProperty(ValueAccessor, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _ValueAccessor,\n    hostBindings: function _ValueAccessor_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"ionBlur\", function _ValueAccessor_ionBlur_HostBindingHandler($event) {\n          return ctx._handleBlurEvent($event.target);\n        });\n      }\n    }\n  }));\n  return ValueAccessor;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst setIonicClasses = element => {\n  raf(() => {\n    const input = element.nativeElement;\n    const hasValue = input.value != null && input.value.toString().length > 0;\n    const classes = getClasses(input);\n    setClasses(input, classes);\n    const item = input.closest('ion-item');\n    if (item) {\n      if (hasValue) {\n        setClasses(item, [...classes, 'item-has-value']);\n      } else {\n        setClasses(item, classes);\n      }\n    }\n  });\n};\nconst getClasses = element => {\n  const classList = element.classList;\n  const classes = [];\n  for (let i = 0; i < classList.length; i++) {\n    const item = classList.item(i);\n    if (item !== null && startsWith(item, 'ng-')) {\n      classes.push(`ion-${item.substring(3)}`);\n    }\n  }\n  return classes;\n};\nconst setClasses = (element, classes) => {\n  const classList = element.classList;\n  classList.remove('ion-valid', 'ion-invalid', 'ion-touched', 'ion-untouched', 'ion-dirty', 'ion-pristine');\n  classList.add(...classes);\n};\nconst startsWith = (input, search) => {\n  return input.substring(0, search.length) === search;\n};\n\n/**\n * Provides a way to customize when activated routes get reused.\n */\nclass IonicRouteStrategy {\n  /**\n   * Whether the given route should detach for later reuse.\n   */\n  shouldDetach(_route) {\n    return false;\n  }\n  /**\n   * Returns `false`, meaning the route (and its subtree) is never reattached\n   */\n  shouldAttach(_route) {\n    return false;\n  }\n  /**\n   * A no-op; the route is never stored since this strategy never detaches routes for later re-use.\n   */\n  store(_route, _detachedTree) {\n    return;\n  }\n  /**\n   * Returns `null` because this strategy does not store routes for later re-use.\n   */\n  retrieve(_route) {\n    return null;\n  }\n  /**\n   * Determines if a route should be reused.\n   * This strategy returns `true` when the future route config and\n   * current route config are identical and all route parameters are identical.\n   */\n  shouldReuseRoute(future, curr) {\n    if (future.routeConfig !== curr.routeConfig) {\n      return false;\n    }\n    // checking router params\n    const futureParams = future.params;\n    const currentParams = curr.params;\n    const keysA = Object.keys(futureParams);\n    const keysB = Object.keys(currentParams);\n    if (keysA.length !== keysB.length) {\n      return false;\n    }\n    // Test for A's keys different from B.\n    for (const key of keysA) {\n      if (currentParams[key] !== futureParams[key]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\n// TODO(FW-2827): types\nclass OverlayBaseController {\n  constructor(ctrl) {\n    _defineProperty(this, \"ctrl\", void 0);\n    this.ctrl = ctrl;\n  }\n  /**\n   * Creates a new overlay\n   */\n  create(opts) {\n    return this.ctrl.create(opts || {});\n  }\n  /**\n   * When `id` is not provided, it dismisses the top overlay.\n   */\n  dismiss(data, role, id) {\n    return this.ctrl.dismiss(data, role, id);\n  }\n  /**\n   * Returns the top overlay.\n   */\n  getTop() {\n    return this.ctrl.getTop();\n  }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngularDelegate, Config, ConfigToken, DomController, IonBackButton, IonModal, IonNav, IonPopover, IonRouterOutlet, IonTabs, IonicRouteStrategy, MenuController, NavController, NavParams, OverlayBaseController, Platform, ProxyCmp, RouterLinkDelegateDirective, RouterLinkWithHrefDelegateDirective, ValueAccessor, bindLifecycleEvents, provideComponentInputBinding, raf, setIonicClasses };","map":{"version":3,"names":["i0","Injectable","Inject","Optional","InjectionToken","inject","NgZone","ApplicationRef","Injector","createComponent","TemplateRef","Directive","ContentChild","EventEmitter","ViewContainerRef","EnvironmentInjector","Attribute","SkipSelf","Input","Output","reflectComponentType","HostListener","ElementRef","ViewChild","i3","NavigationStart","PRIMARY_OUTLET","ChildrenOutletContexts","ActivatedRoute","Router","i1","DOCUMENT","isPlatform","getPlatforms","LIFECYCLE_WILL_ENTER","LIFECYCLE_DID_ENTER","LIFECYCLE_WILL_LEAVE","LIFECYCLE_DID_LEAVE","LIFECYCLE_WILL_UNLOAD","componentOnReady","Subject","fromEvent","BehaviorSubject","combineLatest","of","__decorate","filter","switchMap","distinctUntilChanged","NgControl","_c0","MenuController","constructor","menuController","_defineProperty","open","menuId","close","toggle","enable","shouldEnable","swipeGesture","isOpen","isEnabled","get","getOpen","getMenus","registerAnimation","name","animation","isAnimating","_getOpenSync","_createAnimation","type","menuCmp","_register","menu","_unregister","_setOpen","shouldOpen","animated","DomController","_DomController","read","cb","getQueue","write","_DomController_Factory","__ngFactoryType__","ɵɵdefineInjectable","token","factory","ɵfac","providedIn","ngDevMode","win","window","Ionic","queue","requestAnimationFrame","Platform","_Platform","doc","zone","run","_this$win","defaultView","backButton","subscribeWithPriority","priority","callback","subscribe","ev","register","processNextHandler","proxyEvent","pause","resume","resize","keyboardDidShow","keyboardDidHide","readyResolve","_readyPromise","Promise","res","addEventListener","once","is","platformName","platforms","ready","isRTL","dir","getQueryParam","key","readQueryParam","location","href","isLandscape","isPortrait","_this$win$matchMedia","_this$win2","matchMedia","call","matches","testUserAgent","expression","nav","navigator","userAgent","indexOf","url","width","innerWidth","height","innerHeight","_Platform_Factory","ɵɵinject","replace","regex","RegExp","results","exec","decodeURIComponent","emitter","el","eventName","value","detail","undefined","next","NavController","_NavController","platform","serializer","router","DEFAULT_DIRECTION","DEFAULT_ANIMATED","events","id","restoredState","navigationId","guessDirection","guessAnimation","lastNavId","pop","navigateForward","options","setDirection","animationDirection","navigate","navigateBack","navigateRoot","back","_this","_asyncToGenerator","outlet","topOutlet","parentOutlet","direction","animationBuilder","getAnimation","setTopOutlet","consumeTransition","Array","isArray","urlTree","parse","toString","queryParams","fragment","navigateByUrl","_NavController_Factory","Location","UrlSerializer","Config","_Config","fallback","c","getConfig","getBoolean","getNumber","_Config_Factory","ConfigToken","config","NavParams","data","console","warn","param","AngularDelegate","_AngularDelegate","create","environmentInjector","injector","elementReferenceKey","_this$config$useSetIn","AngularFrameworkDelegate","applicationRef","useSetInputAPI","_AngularDelegate_Factory","enableSignalsSupport","WeakMap","attachViewToDom","container","component","params","cssClasses","resolve","componentProps","attachView","elRefMap","elEventsMap","removeViewFromDom","_container","componentRef","destroy","delete","unbindEvents","childInjector","providers","getProviders","parent","elementInjector","instance","hostElement","nativeElement","error","tagName","toLowerCase","setInput","modal","popover","otherParams","Object","assign","cssClass","classList","add","bindLifecycleEvents","appendChild","hostView","set","LIFECYCLES","element","unregisters","map","handler","removeEventListener","forEach","fn","NavParamsToken","provide","useValue","useFactory","provideNavParamsInjectable","deps","proxyInputs","Cmp","inputs","Prototype","prototype","item","defineProperty","val","z","runOutsideAngular","proxyMethods","methods","methodName","args","arguments","apply","proxyOutputs","ProxyCmp","opts","decorator","cls","defineCustomElementFn","POPOVER_INPUTS","POPOVER_METHODS","IonPopover","_IonPopover","r","isCmpOpen","detectChanges","_IonPopover_Factory","ɵɵdirectiveInject","ChangeDetectorRef","ɵɵdefineDirective","selectors","contentQueries","_IonPopover_ContentQueries","rf","ctx","dirIndex","ɵɵcontentQuery","_t","ɵɵqueryRefresh","ɵɵloadQuery","template","first","alignment","arrow","keepContentsMounted","backdropDismiss","dismissOnSelect","enterAnimation","event","focusTrap","keyboardClose","leaveAnimation","mode","showBackdrop","translucent","trigger","triggerAction","reference","size","side","MODAL_INPUTS","MODAL_METHODS","IonModal","_IonModal","_IonModal_Factory","_IonModal_ContentQueries","backdropBreakpoint","breakpoints","canDismiss","handle","handleBehavior","initialBreakpoint","presentingElement","insertView","views","view","setRoot","setForward","setBack","v","stackId","push","index","getUrl","activatedRoute","createUrlTree","relativeTo","serializeUrl","isTabSwitch","enteringView","leavingView","computeStackId","prefixUrl","segments","toSegments","i","length","path","split","s","trim","destroyView","ref","unlistenEvents","StackController","tabsPrefix","containerEl","navCtrl","createView","_ref$location","nextId","getExistingView","activatedUrlKey","find","vw","changeDetectorRef","reattach","setActive","_router$navigations","_currentNavigation","consumeResult","activeView","tabSwitch","viewsSnapshot","slice","currentNavigation","getCurrentNavigation","navigations","extras","replaceUrl","splice","reused","includes","customAnimation","wait","detach","transition","canGoBack","then","cleanupAsync","deep","getActiveStackId","getStack","viewSavedData","savedData","_primaryOutlet$route","primaryOutlet","route","_routerState","snapshot","savedExtras","startBackTransition","endBackTransition","shouldComplete","skipTransition","cleanup","getLastUrl","getRootUrl","getActiveView","hasRunningTask","runningTask","showGoBack","progressAnimation","enteringEl","leavingEl","commit","duration","task","_this2","promise","finally","activeRoute","locationWithoutParams","locationWithoutFragment","setAttribute","IonRouterOutlet","_IonRouterOutlet","activatedComponentRef","activated","nativeEl","swipe","_swipeGesture","swipeHandler","canStart","stackCtrl","onStart","onEnd","shouldContinue","tabs","commonLocation","elementRef","INPUT_BINDER","optional","parentContexts","onChildOutletCreated","ngOnDestroy","_this$inputBinder","inputBinder","unsubscribeFromRouteData","getContext","ngOnInit","initializeOutletWithName","context","activateWith","isActivated","Error","_activatedRoute","activatedRouteData","attach","_ref","deactivate","activatedView","Map","children","contextSnapshot","deactivateEvents","emit","_this$inputBinder2","cmpRef","saved","updateActivatedRouteProxy","_snapshot$routeConfig","_futureSnapshot","childContexts","getOrCreateContext","component$","activatedRouteProxy","createActivatedRouteProxy","OutletInjector","routeConfig","outletContent","proxyMap","currentActivatedRoute$","bindActivatedRouteToOutletComponent","stackWillChange","activateEvents","stackDidChange","active","getLastRouteView","getRootView","proxy","_paramMap","proxyObservable","_queryParamMap","pipe","current","_IonRouterOutlet_Factory","ɵɵinjectAttribute","outputs","exportAs","notFoundValue","RoutedComponentInputBinder","_RoutedComponentInputBinder","subscribeToRouteData","_this$outletDataSubsc","outletDataSubscriptions","unsubscribe","dataSubscription","mirror","templateName","_RoutedComponentInputBinder_Factory","provideComponentInputBinding","componentInputBindingFactory","componentInputBindingEnabled","BACK_BUTTON_INPUTS","IonBackButton","_IonBackButton","routerOutlet","onClick","_this$routerOutlet","defaultHref","routerAnimation","preventDefault","_IonBackButton_Factory","hostBindings","_IonBackButton_HostBindings","ɵɵlistener","_IonBackButton_click_HostBindingHandler","$event","color","disabled","icon","text","RouterLinkDelegateDirective","_RouterLinkDelegateDirective","locationStrategy","routerLink","updateTargetUrlAndHref","updateTabindex","ngOnChanges","ionicComponents","getAttribute","removeAttribute","_this$routerLink","prepareExternalUrl","routerDirection","_RouterLinkDelegateDirective_Factory","LocationStrategy","RouterLink","_RouterLinkDelegateDirective_HostBindings","_RouterLinkDelegateDirective_click_HostBindingHandler","features","ɵɵNgOnChangesFeature","RouterLinkWithHrefDelegateDirective","_RouterLinkWithHrefDelegateDirective","_this$routerLink2","_RouterLinkWithHrefDelegateDirective_Factory","_RouterLinkWithHrefDelegateDirective_HostBindings","_RouterLinkWithHrefDelegateDirective_click_HostBindingHandler","NAV_INPUTS","NAV_METHODS","IonNav","_IonNav","angularDelegate","delegate","_IonNav_Factory","root","rootParams","IonTabs","_IonTabs","ngAfterViewInit","firstTab","hasTab","setActiveTab","tab","ngAfterContentInit","detectSlotChanges","ngAfterContentChecked","onStackWillChange","ionTabsWillChange","onStackDidChange","tabBar","selectedTab","ionTabsDidChange","select","tabOrEvent","isTabString","alreadySelected","tabRootUrl","stopPropagation","activeStackId","rootView","navigationExtras","lastRoute","t","leavingTab","getSelected","_this$selectedTab","tabBars","currentSlot","tabBarSlot","relocateTabBar","tabsInner","before","after","_IonTabs_Factory","viewQuery","_IonTabs_Query","ɵɵviewQuery","_IonTabs_HostBindings","_IonTabs_ionTabButtonClick_HostBindingHandler","raf","h","__zone_symbol__requestAnimationFrame","setTimeout","ValueAccessor","_ValueAccessor","writeValue","lastValue","setIonicClasses","handleValueChange","onChange","_handleBlurEvent","onTouched","registerOnChange","registerOnTouched","setDisabledState","isDisabled","statusChanges","ngControl","formControl","control","methodsToPatch","method","oldFn","bind","_ValueAccessor_Factory","_ValueAccessor_HostBindings","_ValueAccessor_ionBlur_HostBindingHandler","target","input","hasValue","classes","getClasses","setClasses","closest","startsWith","substring","remove","search","IonicRouteStrategy","shouldDetach","_route","shouldAttach","store","_detachedTree","retrieve","shouldReuseRoute","future","curr","futureParams","currentParams","keysA","keys","keysB","OverlayBaseController","ctrl","dismiss","role","getTop"],"sources":["/Users/user/Documents/Workspace/englishApp/englishAppFrontend/node_modules/@ionic/angular/fesm2022/ionic-angular-common.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, Inject, Optional, InjectionToken, inject, NgZone, ApplicationRef, Injector, createComponent, TemplateRef, Directive, ContentChild, EventEmitter, ViewContainerRef, EnvironmentInjector, Attribute, SkipSelf, Input, Output, reflectComponentType, HostListener, ElementRef, ViewChild } from '@angular/core';\nimport * as i3 from '@angular/router';\nimport { NavigationStart, PRIMARY_OUTLET, ChildrenOutletContexts, ActivatedRoute, Router } from '@angular/router';\nimport * as i1 from '@angular/common';\nimport { DOCUMENT } from '@angular/common';\nimport { isPlatform, getPlatforms, LIFECYCLE_WILL_ENTER, LIFECYCLE_DID_ENTER, LIFECYCLE_WILL_LEAVE, LIFECYCLE_DID_LEAVE, LIFECYCLE_WILL_UNLOAD, componentOnReady } from '@ionic/core/components';\nimport { Subject, fromEvent, BehaviorSubject, combineLatest, of } from 'rxjs';\nimport { __decorate } from 'tslib';\nimport { filter, switchMap, distinctUntilChanged } from 'rxjs/operators';\nimport { NgControl } from '@angular/forms';\n\nclass MenuController {\n    menuController;\n    constructor(menuController) {\n        this.menuController = menuController;\n    }\n    /**\n     * Programmatically open the Menu.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return returns a promise when the menu is fully opened\n     */\n    open(menuId) {\n        return this.menuController.open(menuId);\n    }\n    /**\n     * Programmatically close the Menu. If no `menuId` is given as the first\n     * argument then it'll close any menu which is open. If a `menuId`\n     * is given then it'll close that exact menu.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return returns a promise when the menu is fully closed\n     */\n    close(menuId) {\n        return this.menuController.close(menuId);\n    }\n    /**\n     * Toggle the menu. If it's closed, it will open, and if opened, it\n     * will close.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return returns a promise when the menu has been toggled\n     */\n    toggle(menuId) {\n        return this.menuController.toggle(menuId);\n    }\n    /**\n     * Used to enable or disable a menu. For example, there could be multiple\n     * left menus, but only one of them should be able to be opened at the same\n     * time. If there are multiple menus on the same side, then enabling one menu\n     * will also automatically disable all the others that are on the same side.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return Returns the instance of the menu, which is useful for chaining.\n     */\n    enable(shouldEnable, menuId) {\n        return this.menuController.enable(shouldEnable, menuId);\n    }\n    /**\n     * Used to enable or disable the ability to swipe open the menu.\n     * @param shouldEnable  True if it should be swipe-able, false if not.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return Returns the instance of the menu, which is useful for chaining.\n     */\n    swipeGesture(shouldEnable, menuId) {\n        return this.menuController.swipeGesture(shouldEnable, menuId);\n    }\n    /**\n     * @param [menuId] Optionally get the menu by its id, or side.\n     * @return Returns true if the specified menu is currently open, otherwise false.\n     * If the menuId is not specified, it returns true if ANY menu is currenly open.\n     */\n    isOpen(menuId) {\n        return this.menuController.isOpen(menuId);\n    }\n    /**\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return Returns true if the menu is currently enabled, otherwise false.\n     */\n    isEnabled(menuId) {\n        return this.menuController.isEnabled(menuId);\n    }\n    /**\n     * Used to get a menu instance. If a `menuId` is not provided then it'll\n     * return the first menu found. If a `menuId` is `left` or `right`, then\n     * it'll return the enabled menu on that side. Otherwise, if a `menuId` is\n     * provided, then it'll try to find the menu using the menu's `id`\n     * property. If a menu is not found then it'll return `null`.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return Returns the instance of the menu if found, otherwise `null`.\n     */\n    get(menuId) {\n        return this.menuController.get(menuId);\n    }\n    /**\n     * @return Returns the instance of the menu already opened, otherwise `null`.\n     */\n    getOpen() {\n        return this.menuController.getOpen();\n    }\n    /**\n     * @return Returns an array of all menu instances.\n     */\n    getMenus() {\n        return this.menuController.getMenus();\n    }\n    registerAnimation(name, animation) {\n        return this.menuController.registerAnimation(name, animation);\n    }\n    isAnimating() {\n        return this.menuController.isAnimating();\n    }\n    _getOpenSync() {\n        return this.menuController._getOpenSync();\n    }\n    _createAnimation(type, menuCmp) {\n        return this.menuController._createAnimation(type, menuCmp);\n    }\n    _register(menu) {\n        return this.menuController._register(menu);\n    }\n    _unregister(menu) {\n        return this.menuController._unregister(menu);\n    }\n    _setOpen(menu, shouldOpen, animated) {\n        return this.menuController._setOpen(menu, shouldOpen, animated);\n    }\n}\n\nclass DomController {\n    /**\n     * Schedules a task to run during the READ phase of the next frame.\n     * This task should only read the DOM, but never modify it.\n     */\n    read(cb) {\n        getQueue().read(cb);\n    }\n    /**\n     * Schedules a task to run during the WRITE phase of the next frame.\n     * This task should write the DOM, but never READ it.\n     */\n    write(cb) {\n        getQueue().write(cb);\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: DomController, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: DomController, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: DomController, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }] });\nconst getQueue = () => {\n    const win = typeof window !== 'undefined' ? window : null;\n    if (win != null) {\n        const Ionic = win.Ionic;\n        if (Ionic?.queue) {\n            return Ionic.queue;\n        }\n        return {\n            read: (cb) => win.requestAnimationFrame(cb),\n            write: (cb) => win.requestAnimationFrame(cb),\n        };\n    }\n    return {\n        read: (cb) => cb(),\n        write: (cb) => cb(),\n    };\n};\n\nclass Platform {\n    doc;\n    _readyPromise;\n    win;\n    /**\n     * @hidden\n     */\n    backButton = new Subject();\n    /**\n     * The keyboardDidShow event emits when the\n     * on-screen keyboard is presented.\n     */\n    keyboardDidShow = new Subject();\n    /**\n     * The keyboardDidHide event emits when the\n     * on-screen keyboard is hidden.\n     */\n    keyboardDidHide = new Subject();\n    /**\n     * The pause event emits when the native platform puts the application\n     * into the background, typically when the user switches to a different\n     * application. This event would emit when a Cordova app is put into\n     * the background, however, it would not fire on a standard web browser.\n     */\n    pause = new Subject();\n    /**\n     * The resume event emits when the native platform pulls the application\n     * out from the background. This event would emit when a Cordova app comes\n     * out from the background, however, it would not fire on a standard web browser.\n     */\n    resume = new Subject();\n    /**\n     * The resize event emits when the browser window has changed dimensions. This\n     * could be from a browser window being physically resized, or from a device\n     * changing orientation.\n     */\n    resize = new Subject();\n    constructor(doc, zone) {\n        this.doc = doc;\n        zone.run(() => {\n            this.win = doc.defaultView;\n            this.backButton.subscribeWithPriority = function (priority, callback) {\n                return this.subscribe((ev) => {\n                    return ev.register(priority, (processNextHandler) => zone.run(() => callback(processNextHandler)));\n                });\n            };\n            proxyEvent(this.pause, doc, 'pause', zone);\n            proxyEvent(this.resume, doc, 'resume', zone);\n            proxyEvent(this.backButton, doc, 'ionBackButton', zone);\n            proxyEvent(this.resize, this.win, 'resize', zone);\n            proxyEvent(this.keyboardDidShow, this.win, 'ionKeyboardDidShow', zone);\n            proxyEvent(this.keyboardDidHide, this.win, 'ionKeyboardDidHide', zone);\n            let readyResolve;\n            this._readyPromise = new Promise((res) => {\n                readyResolve = res;\n            });\n            if (this.win?.['cordova']) {\n                doc.addEventListener('deviceready', () => {\n                    readyResolve('cordova');\n                }, { once: true });\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                readyResolve('dom');\n            }\n        });\n    }\n    /**\n     * @returns returns true/false based on platform.\n     * @description\n     * Depending on the platform the user is on, `is(platformName)` will\n     * return `true` or `false`. Note that the same app can return `true`\n     * for more than one platform name. For example, an app running from\n     * an iPad would return `true` for the platform names: `mobile`,\n     * `ios`, `ipad`, and `tablet`. Additionally, if the app was running\n     * from Cordova then `cordova` would be true, and if it was running\n     * from a web browser on the iPad then `mobileweb` would be `true`.\n     *\n     * ```\n     * import { Platform } from 'ionic-angular';\n     *\n     * @Component({...})\n     * export MyPage {\n     *   constructor(public platform: Platform) {\n     *     if (this.platform.is('ios')) {\n     *       // This will only print when on iOS\n     *       console.log('I am an iOS device!');\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * | Platform Name   | Description                        |\n     * |-----------------|------------------------------------|\n     * | android         | on a device running Android.       |\n     * | capacitor       | on a device running Capacitor.     |\n     * | cordova         | on a device running Cordova.       |\n     * | ios             | on a device running iOS.           |\n     * | ipad            | on an iPad device.                 |\n     * | iphone          | on an iPhone device.               |\n     * | phablet         | on a phablet device.               |\n     * | tablet          | on a tablet device.                |\n     * | electron        | in Electron on a desktop device.   |\n     * | pwa             | as a PWA app.                      |\n     * | mobile          | on a mobile device.                |\n     * | mobileweb       | on a mobile device in a browser.   |\n     * | desktop         | on a desktop device.               |\n     * | hybrid          | is a cordova or capacitor app.     |\n     *\n     */\n    is(platformName) {\n        return isPlatform(this.win, platformName);\n    }\n    /**\n     * @returns the array of platforms\n     * @description\n     * Depending on what device you are on, `platforms` can return multiple values.\n     * Each possible value is a hierarchy of platforms. For example, on an iPhone,\n     * it would return `mobile`, `ios`, and `iphone`.\n     *\n     * ```\n     * import { Platform } from 'ionic-angular';\n     *\n     * @Component({...})\n     * export MyPage {\n     *   constructor(public platform: Platform) {\n     *     // This will print an array of the current platforms\n     *     console.log(this.platform.platforms());\n     *   }\n     * }\n     * ```\n     */\n    platforms() {\n        return getPlatforms(this.win);\n    }\n    /**\n     * Returns a promise when the platform is ready and native functionality\n     * can be called. If the app is running from within a web browser, then\n     * the promise will resolve when the DOM is ready. When the app is running\n     * from an application engine such as Cordova, then the promise will\n     * resolve when Cordova triggers the `deviceready` event.\n     *\n     * The resolved value is the `readySource`, which states which platform\n     * ready was used. For example, when Cordova is ready, the resolved ready\n     * source is `cordova`. The default ready source value will be `dom`. The\n     * `readySource` is useful if different logic should run depending on the\n     * platform the app is running from. For example, only Cordova can execute\n     * the status bar plugin, so the web should not run status bar plugin logic.\n     *\n     * ```\n     * import { Component } from '@angular/core';\n     * import { Platform } from 'ionic-angular';\n     *\n     * @Component({...})\n     * export MyApp {\n     *   constructor(public platform: Platform) {\n     *     this.platform.ready().then((readySource) => {\n     *       console.log('Platform ready from', readySource);\n     *       // Platform now ready, execute any required native code\n     *     });\n     *   }\n     * }\n     * ```\n     */\n    ready() {\n        return this._readyPromise;\n    }\n    /**\n     * Returns if this app is using right-to-left language direction or not.\n     * We recommend the app's `index.html` file already has the correct `dir`\n     * attribute value set, such as `<html dir=\"ltr\">` or `<html dir=\"rtl\">`.\n     * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)\n     */\n    get isRTL() {\n        return this.doc.dir === 'rtl';\n    }\n    /**\n     * Get the query string parameter\n     */\n    getQueryParam(key) {\n        return readQueryParam(this.win.location.href, key);\n    }\n    /**\n     * Returns `true` if the app is in landscape mode.\n     */\n    isLandscape() {\n        return !this.isPortrait();\n    }\n    /**\n     * Returns `true` if the app is in portrait mode.\n     */\n    isPortrait() {\n        return this.win.matchMedia?.('(orientation: portrait)').matches;\n    }\n    testUserAgent(expression) {\n        const nav = this.win.navigator;\n        return !!(nav?.userAgent && nav.userAgent.indexOf(expression) >= 0);\n    }\n    /**\n     * Get the current url.\n     */\n    url() {\n        return this.win.location.href;\n    }\n    /**\n     * Gets the width of the platform's viewport using `window.innerWidth`.\n     */\n    width() {\n        return this.win.innerWidth;\n    }\n    /**\n     * Gets the height of the platform's viewport using `window.innerHeight`.\n     */\n    height() {\n        return this.win.innerHeight;\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: Platform, deps: [{ token: DOCUMENT }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: Platform, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: Platform, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: i0.NgZone }]; } });\nconst readQueryParam = (url, key) => {\n    key = key.replace(/[[\\]\\\\]/g, '\\\\$&');\n    const regex = new RegExp('[\\\\?&]' + key + '=([^&#]*)');\n    const results = regex.exec(url);\n    return results ? decodeURIComponent(results[1].replace(/\\+/g, ' ')) : null;\n};\nconst proxyEvent = (emitter, el, eventName, zone) => {\n    if (el) {\n        el.addEventListener(eventName, (ev) => {\n            /**\n             * `zone.run` is required to make sure that we are running inside the Angular zone\n             * at all times. This is necessary since an app that has Capacitor will\n             * override the `document.addEventListener` with its own implementation.\n             * The override causes the event to no longer be in the Angular zone.\n             */\n            zone.run(() => {\n                // ?? cordova might emit \"null\" events\n                const value = ev != null ? ev.detail : undefined;\n                emitter.next(value);\n            });\n        });\n    }\n};\n\nclass NavController {\n    location;\n    serializer;\n    router;\n    topOutlet;\n    direction = DEFAULT_DIRECTION;\n    animated = DEFAULT_ANIMATED;\n    animationBuilder;\n    guessDirection = 'forward';\n    guessAnimation;\n    lastNavId = -1;\n    constructor(platform, location, serializer, router) {\n        this.location = location;\n        this.serializer = serializer;\n        this.router = router;\n        // Subscribe to router events to detect direction\n        if (router) {\n            router.events.subscribe((ev) => {\n                if (ev instanceof NavigationStart) {\n                    // restoredState is set if the browser back/forward button is used\n                    const id = ev.restoredState ? ev.restoredState.navigationId : ev.id;\n                    this.guessDirection = this.guessAnimation = id < this.lastNavId ? 'back' : 'forward';\n                    this.lastNavId = this.guessDirection === 'forward' ? ev.id : id;\n                }\n            });\n        }\n        // Subscribe to backButton events\n        platform.backButton.subscribeWithPriority(0, (processNextHandler) => {\n            this.pop();\n            processNextHandler();\n        });\n    }\n    /**\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n     * it's equivalent to calling `this.router.navigateByUrl()`, but it's explicit about the **direction** of the transition.\n     *\n     * Going **forward** means that a new page is going to be pushed to the stack of the outlet (ion-router-outlet),\n     * and that it will show a \"forward\" animation by default.\n     *\n     * Navigating forward can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n     *\n     * ```html\n     * <a routerLink=\"/path/to/page\" routerDirection=\"forward\">Link</a>\n     * ```\n     */\n    navigateForward(url, options = {}) {\n        this.setDirection('forward', options.animated, options.animationDirection, options.animation);\n        return this.navigate(url, options);\n    }\n    /**\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n     * it's equivalent to calling:\n     *\n     * ```ts\n     * this.navController.setDirection('back');\n     * this.router.navigateByUrl(path);\n     * ```\n     *\n     * Going **back** means that all the pages in the stack until the navigated page is found will be popped,\n     * and that it will show a \"back\" animation by default.\n     *\n     * Navigating back can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n     *\n     * ```html\n     * <a routerLink=\"/path/to/page\" routerDirection=\"back\">Link</a>\n     * ```\n     */\n    navigateBack(url, options = {}) {\n        this.setDirection('back', options.animated, options.animationDirection, options.animation);\n        return this.navigate(url, options);\n    }\n    /**\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n     * it's equivalent to calling:\n     *\n     * ```ts\n     * this.navController.setDirection('root');\n     * this.router.navigateByUrl(path);\n     * ```\n     *\n     * Going **root** means that all existing pages in the stack will be removed,\n     * and the navigated page will become the single page in the stack.\n     *\n     * Navigating root can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n     *\n     * ```html\n     * <a routerLink=\"/path/to/page\" routerDirection=\"root\">Link</a>\n     * ```\n     */\n    navigateRoot(url, options = {}) {\n        this.setDirection('root', options.animated, options.animationDirection, options.animation);\n        return this.navigate(url, options);\n    }\n    /**\n     * Same as [Location](https://angular.io/api/common/Location)'s back() method.\n     * It will use the standard `window.history.back()` under the hood, but featuring a `back` animation\n     * by default.\n     */\n    back(options = { animated: true, animationDirection: 'back' }) {\n        this.setDirection('back', options.animated, options.animationDirection, options.animation);\n        return this.location.back();\n    }\n    /**\n     * This methods goes back in the context of Ionic's stack navigation.\n     *\n     * It recursively finds the top active `ion-router-outlet` and calls `pop()`.\n     * This is the recommended way to go back when you are using `ion-router-outlet`.\n     *\n     * Resolves to `true` if it was able to pop.\n     */\n    async pop() {\n        let outlet = this.topOutlet;\n        while (outlet) {\n            if (await outlet.pop()) {\n                return true;\n            }\n            else {\n                outlet = outlet.parentOutlet;\n            }\n        }\n        return false;\n    }\n    /**\n     * This methods specifies the direction of the next navigation performed by the Angular router.\n     *\n     * `setDirection()` does not trigger any transition, it just sets some flags to be consumed by `ion-router-outlet`.\n     *\n     * It's recommended to use `navigateForward()`, `navigateBack()` and `navigateRoot()` instead of `setDirection()`.\n     */\n    setDirection(direction, animated, animationDirection, animationBuilder) {\n        this.direction = direction;\n        this.animated = getAnimation(direction, animated, animationDirection);\n        this.animationBuilder = animationBuilder;\n    }\n    /**\n     * @internal\n     */\n    setTopOutlet(outlet) {\n        this.topOutlet = outlet;\n    }\n    /**\n     * @internal\n     */\n    consumeTransition() {\n        let direction = 'root';\n        let animation;\n        const animationBuilder = this.animationBuilder;\n        if (this.direction === 'auto') {\n            direction = this.guessDirection;\n            animation = this.guessAnimation;\n        }\n        else {\n            animation = this.animated;\n            direction = this.direction;\n        }\n        this.direction = DEFAULT_DIRECTION;\n        this.animated = DEFAULT_ANIMATED;\n        this.animationBuilder = undefined;\n        return {\n            direction,\n            animation,\n            animationBuilder,\n        };\n    }\n    navigate(url, options) {\n        if (Array.isArray(url)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return this.router.navigate(url, options);\n        }\n        else {\n            /**\n             * navigateByUrl ignores any properties that\n             * would change the url, so things like queryParams\n             * would be ignored unless we create a url tree\n             * More Info: https://github.com/angular/angular/issues/18798\n             */\n            const urlTree = this.serializer.parse(url.toString());\n            if (options.queryParams !== undefined) {\n                urlTree.queryParams = { ...options.queryParams };\n            }\n            if (options.fragment !== undefined) {\n                urlTree.fragment = options.fragment;\n            }\n            /**\n             * `navigateByUrl` will still apply `NavigationExtras` properties\n             * that do not modify the url, such as `replaceUrl` which is why\n             * `options` is passed in here.\n             */\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return this.router.navigateByUrl(urlTree, options);\n        }\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: NavController, deps: [{ token: Platform }, { token: i1.Location }, { token: i3.UrlSerializer }, { token: i3.Router, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: NavController, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: NavController, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }], ctorParameters: function () { return [{ type: Platform }, { type: i1.Location }, { type: i3.UrlSerializer }, { type: i3.Router, decorators: [{\n                    type: Optional\n                }] }]; } });\nconst getAnimation = (direction, animated, animationDirection) => {\n    if (animated === false) {\n        return undefined;\n    }\n    if (animationDirection !== undefined) {\n        return animationDirection;\n    }\n    if (direction === 'forward' || direction === 'back') {\n        return direction;\n    }\n    else if (direction === 'root' && animated === true) {\n        return 'forward';\n    }\n    return undefined;\n};\nconst DEFAULT_DIRECTION = 'auto';\nconst DEFAULT_ANIMATED = undefined;\n\nclass Config {\n    get(key, fallback) {\n        const c = getConfig();\n        if (c) {\n            return c.get(key, fallback);\n        }\n        return null;\n    }\n    getBoolean(key, fallback) {\n        const c = getConfig();\n        if (c) {\n            return c.getBoolean(key, fallback);\n        }\n        return false;\n    }\n    getNumber(key, fallback) {\n        const c = getConfig();\n        if (c) {\n            return c.getNumber(key, fallback);\n        }\n        return 0;\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: Config, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: Config, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: Config, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }] });\nconst ConfigToken = new InjectionToken('USERCONFIG');\nconst getConfig = () => {\n    if (typeof window !== 'undefined') {\n        const Ionic = window.Ionic;\n        if (Ionic?.config) {\n            return Ionic.config;\n        }\n    }\n    return null;\n};\n\n/**\n * @description\n * NavParams are an object that exists on a page and can contain data for that particular view.\n * Similar to how data was pass to a view in V1 with `$stateParams`, NavParams offer a much more flexible\n * option with a simple `get` method.\n *\n * @usage\n * ```ts\n * import { NavParams } from '@ionic/angular';\n *\n * export class MyClass{\n *\n *  constructor(navParams: NavParams){\n *    // userParams is an object we have in our nav-parameters\n *    navParams.get('userParams');\n *  }\n *\n * }\n * ```\n */\nclass NavParams {\n    data;\n    constructor(data = {}) {\n        this.data = data;\n        console.warn(`[Ionic Warning]: NavParams has been deprecated in favor of using Angular's input API. Developers should migrate to either the @Input decorator or the Signals-based input API.`);\n    }\n    /**\n     * Get the value of a nav-parameter for the current view\n     *\n     * ```ts\n     * import { NavParams } from 'ionic-angular';\n     *\n     * export class MyClass{\n     *  constructor(public navParams: NavParams){\n     *    // userParams is an object we have in our nav-parameters\n     *    this.navParams.get('userParams');\n     *  }\n     * }\n     * ```\n     *\n     * @param param Which param you want to look up\n     */\n    get(param) {\n        return this.data[param];\n    }\n}\n\n// TODO(FW-2827): types\nclass AngularDelegate {\n    zone = inject(NgZone);\n    applicationRef = inject(ApplicationRef);\n    config = inject(ConfigToken);\n    create(environmentInjector, injector, elementReferenceKey) {\n        return new AngularFrameworkDelegate(environmentInjector, injector, this.applicationRef, this.zone, elementReferenceKey, this.config.useSetInputAPI ?? false);\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: AngularDelegate, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: AngularDelegate });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: AngularDelegate, decorators: [{\n            type: Injectable\n        }] });\nclass AngularFrameworkDelegate {\n    environmentInjector;\n    injector;\n    applicationRef;\n    zone;\n    elementReferenceKey;\n    enableSignalsSupport;\n    elRefMap = new WeakMap();\n    elEventsMap = new WeakMap();\n    constructor(environmentInjector, injector, applicationRef, zone, elementReferenceKey, enableSignalsSupport) {\n        this.environmentInjector = environmentInjector;\n        this.injector = injector;\n        this.applicationRef = applicationRef;\n        this.zone = zone;\n        this.elementReferenceKey = elementReferenceKey;\n        this.enableSignalsSupport = enableSignalsSupport;\n    }\n    attachViewToDom(container, component, params, cssClasses) {\n        return this.zone.run(() => {\n            return new Promise((resolve) => {\n                const componentProps = {\n                    ...params,\n                };\n                /**\n                 * Ionic Angular passes a reference to a modal\n                 * or popover that can be accessed using a\n                 * variable in the overlay component. If\n                 * elementReferenceKey is defined, then we should\n                 * pass a reference to the component using\n                 * elementReferenceKey as the key.\n                 */\n                if (this.elementReferenceKey !== undefined) {\n                    componentProps[this.elementReferenceKey] = container;\n                }\n                const el = attachView(this.zone, this.environmentInjector, this.injector, this.applicationRef, this.elRefMap, this.elEventsMap, container, component, componentProps, cssClasses, this.elementReferenceKey, this.enableSignalsSupport);\n                resolve(el);\n            });\n        });\n    }\n    removeViewFromDom(_container, component) {\n        return this.zone.run(() => {\n            return new Promise((resolve) => {\n                const componentRef = this.elRefMap.get(component);\n                if (componentRef) {\n                    componentRef.destroy();\n                    this.elRefMap.delete(component);\n                    const unbindEvents = this.elEventsMap.get(component);\n                    if (unbindEvents) {\n                        unbindEvents();\n                        this.elEventsMap.delete(component);\n                    }\n                }\n                resolve();\n            });\n        });\n    }\n}\nconst attachView = (zone, environmentInjector, injector, applicationRef, elRefMap, elEventsMap, container, component, params, cssClasses, elementReferenceKey, enableSignalsSupport) => {\n    /**\n     * Wraps the injector with a custom injector that\n     * provides NavParams to the component.\n     *\n     * NavParams is a legacy feature from Ionic v3 that allows\n     * Angular developers to provide data to a component\n     * and access it by providing NavParams as a dependency\n     * in the constructor.\n     *\n     * The modern approach is to access the data directly\n     * from the component's class instance.\n     */\n    const childInjector = Injector.create({\n        providers: getProviders(params),\n        parent: injector,\n    });\n    const componentRef = createComponent(component, {\n        environmentInjector,\n        elementInjector: childInjector,\n    });\n    const instance = componentRef.instance;\n    const hostElement = componentRef.location.nativeElement;\n    if (params) {\n        /**\n         * For modals and popovers, a reference to the component is\n         * added to `params` during the call to attachViewToDom. If\n         * a reference using this name is already set, this means\n         * the app is trying to use the name as a component prop,\n         * which will cause collisions.\n         */\n        if (elementReferenceKey && instance[elementReferenceKey] !== undefined) {\n            console.error(`[Ionic Error]: ${elementReferenceKey} is a reserved property when using ${container.tagName.toLowerCase()}. Rename or remove the \"${elementReferenceKey}\" property from ${component.name}.`);\n        }\n        /**\n         * Angular 14.1 added support for setInput\n         * so we need to fall back to Object.assign\n         * for Angular 14.0.\n         */\n        if (enableSignalsSupport === true && componentRef.setInput !== undefined) {\n            const { modal, popover, ...otherParams } = params;\n            /**\n             * Any key/value pairs set in componentProps\n             * must be set as inputs on the component instance.\n             */\n            for (const key in otherParams) {\n                componentRef.setInput(key, otherParams[key]);\n            }\n            /**\n             * Using setInput will cause an error when\n             * setting modal/popover on a component that\n             * does not define them as an input. For backwards\n             * compatibility purposes we fall back to using\n             * Object.assign for these properties.\n             */\n            if (modal !== undefined) {\n                Object.assign(instance, { modal });\n            }\n            if (popover !== undefined) {\n                Object.assign(instance, { popover });\n            }\n        }\n        else {\n            Object.assign(instance, params);\n        }\n    }\n    if (cssClasses) {\n        for (const cssClass of cssClasses) {\n            hostElement.classList.add(cssClass);\n        }\n    }\n    const unbindEvents = bindLifecycleEvents(zone, instance, hostElement);\n    container.appendChild(hostElement);\n    applicationRef.attachView(componentRef.hostView);\n    elRefMap.set(hostElement, componentRef);\n    elEventsMap.set(hostElement, unbindEvents);\n    return hostElement;\n};\nconst LIFECYCLES = [\n    LIFECYCLE_WILL_ENTER,\n    LIFECYCLE_DID_ENTER,\n    LIFECYCLE_WILL_LEAVE,\n    LIFECYCLE_DID_LEAVE,\n    LIFECYCLE_WILL_UNLOAD,\n];\nconst bindLifecycleEvents = (zone, instance, element) => {\n    return zone.run(() => {\n        const unregisters = LIFECYCLES.filter((eventName) => typeof instance[eventName] === 'function').map((eventName) => {\n            const handler = (ev) => instance[eventName](ev.detail);\n            element.addEventListener(eventName, handler);\n            return () => element.removeEventListener(eventName, handler);\n        });\n        return () => unregisters.forEach((fn) => fn());\n    });\n};\nconst NavParamsToken = new InjectionToken('NavParamsToken');\nconst getProviders = (params) => {\n    return [\n        {\n            provide: NavParamsToken,\n            useValue: params,\n        },\n        {\n            provide: NavParams,\n            useFactory: provideNavParamsInjectable,\n            deps: [NavParamsToken],\n        },\n    ];\n};\nconst provideNavParamsInjectable = (params) => {\n    return new NavParams(params);\n};\n\n// TODO: Is there a way we can grab this from angular-component-lib instead?\n/* eslint-disable */\n/* tslint:disable */\nconst proxyInputs = (Cmp, inputs) => {\n    const Prototype = Cmp.prototype;\n    inputs.forEach((item) => {\n        Object.defineProperty(Prototype, item, {\n            get() {\n                return this.el[item];\n            },\n            set(val) {\n                this.z.runOutsideAngular(() => (this.el[item] = val));\n            },\n        });\n    });\n};\nconst proxyMethods = (Cmp, methods) => {\n    const Prototype = Cmp.prototype;\n    methods.forEach((methodName) => {\n        Prototype[methodName] = function () {\n            const args = arguments;\n            return this.z.runOutsideAngular(() => this.el[methodName].apply(this.el, args));\n        };\n    });\n};\nconst proxyOutputs = (instance, el, events) => {\n    events.forEach((eventName) => (instance[eventName] = fromEvent(el, eventName)));\n};\n// tslint:disable-next-line: only-arrow-functions\nfunction ProxyCmp(opts) {\n    const decorator = function (cls) {\n        const { defineCustomElementFn, inputs, methods } = opts;\n        if (defineCustomElementFn !== undefined) {\n            defineCustomElementFn();\n        }\n        if (inputs) {\n            proxyInputs(cls, inputs);\n        }\n        if (methods) {\n            proxyMethods(cls, methods);\n        }\n        return cls;\n    };\n    return decorator;\n}\n\nconst POPOVER_INPUTS = [\n    'alignment',\n    'animated',\n    'arrow',\n    'keepContentsMounted',\n    'backdropDismiss',\n    'cssClass',\n    'dismissOnSelect',\n    'enterAnimation',\n    'event',\n    'focusTrap',\n    'isOpen',\n    'keyboardClose',\n    'leaveAnimation',\n    'mode',\n    'showBackdrop',\n    'translucent',\n    'trigger',\n    'triggerAction',\n    'reference',\n    'size',\n    'side',\n];\nconst POPOVER_METHODS = ['present', 'dismiss', 'onDidDismiss', 'onWillDismiss'];\nlet IonPopover = class IonPopover {\n    z;\n    // TODO(FW-2827): type\n    template;\n    isCmpOpen = false;\n    el;\n    constructor(c, r, z) {\n        this.z = z;\n        this.el = r.nativeElement;\n        this.el.addEventListener('ionMount', () => {\n            this.isCmpOpen = true;\n            c.detectChanges();\n        });\n        this.el.addEventListener('didDismiss', () => {\n            this.isCmpOpen = false;\n            c.detectChanges();\n        });\n        proxyOutputs(this, this.el, [\n            'ionPopoverDidPresent',\n            'ionPopoverWillPresent',\n            'ionPopoverWillDismiss',\n            'ionPopoverDidDismiss',\n            'didPresent',\n            'willPresent',\n            'willDismiss',\n            'didDismiss',\n        ]);\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonPopover, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\n    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.12\", type: IonPopover, selector: \"ion-popover\", inputs: { alignment: \"alignment\", animated: \"animated\", arrow: \"arrow\", keepContentsMounted: \"keepContentsMounted\", backdropDismiss: \"backdropDismiss\", cssClass: \"cssClass\", dismissOnSelect: \"dismissOnSelect\", enterAnimation: \"enterAnimation\", event: \"event\", focusTrap: \"focusTrap\", isOpen: \"isOpen\", keyboardClose: \"keyboardClose\", leaveAnimation: \"leaveAnimation\", mode: \"mode\", showBackdrop: \"showBackdrop\", translucent: \"translucent\", trigger: \"trigger\", triggerAction: \"triggerAction\", reference: \"reference\", size: \"size\", side: \"side\" }, queries: [{ propertyName: \"template\", first: true, predicate: TemplateRef, descendants: true }], ngImport: i0 });\n};\nIonPopover = __decorate([\n    ProxyCmp({\n        inputs: POPOVER_INPUTS,\n        methods: POPOVER_METHODS,\n    })\n    /**\n     * @Component extends from @Directive\n     * so by defining the inputs here we\n     * do not need to re-define them for the\n     * lazy loaded popover.\n     */\n], IonPopover);\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonPopover, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'ion-popover',\n                    // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property\n                    inputs: POPOVER_INPUTS,\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }]; }, propDecorators: { template: [{\n                type: ContentChild,\n                args: [TemplateRef, { static: false }]\n            }] } });\n\nconst MODAL_INPUTS = [\n    'animated',\n    'keepContentsMounted',\n    'backdropBreakpoint',\n    'backdropDismiss',\n    'breakpoints',\n    'canDismiss',\n    'cssClass',\n    'enterAnimation',\n    'event',\n    'focusTrap',\n    'handle',\n    'handleBehavior',\n    'initialBreakpoint',\n    'isOpen',\n    'keyboardClose',\n    'leaveAnimation',\n    'mode',\n    'presentingElement',\n    'showBackdrop',\n    'translucent',\n    'trigger',\n];\nconst MODAL_METHODS = [\n    'present',\n    'dismiss',\n    'onDidDismiss',\n    'onWillDismiss',\n    'setCurrentBreakpoint',\n    'getCurrentBreakpoint',\n];\nlet IonModal = class IonModal {\n    z;\n    // TODO(FW-2827): type\n    template;\n    isCmpOpen = false;\n    el;\n    constructor(c, r, z) {\n        this.z = z;\n        this.el = r.nativeElement;\n        this.el.addEventListener('ionMount', () => {\n            this.isCmpOpen = true;\n            c.detectChanges();\n        });\n        this.el.addEventListener('didDismiss', () => {\n            this.isCmpOpen = false;\n            c.detectChanges();\n        });\n        proxyOutputs(this, this.el, [\n            'ionModalDidPresent',\n            'ionModalWillPresent',\n            'ionModalWillDismiss',\n            'ionModalDidDismiss',\n            'ionBreakpointDidChange',\n            'didPresent',\n            'willPresent',\n            'willDismiss',\n            'didDismiss',\n        ]);\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonModal, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\n    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.12\", type: IonModal, selector: \"ion-modal\", inputs: { animated: \"animated\", keepContentsMounted: \"keepContentsMounted\", backdropBreakpoint: \"backdropBreakpoint\", backdropDismiss: \"backdropDismiss\", breakpoints: \"breakpoints\", canDismiss: \"canDismiss\", cssClass: \"cssClass\", enterAnimation: \"enterAnimation\", event: \"event\", focusTrap: \"focusTrap\", handle: \"handle\", handleBehavior: \"handleBehavior\", initialBreakpoint: \"initialBreakpoint\", isOpen: \"isOpen\", keyboardClose: \"keyboardClose\", leaveAnimation: \"leaveAnimation\", mode: \"mode\", presentingElement: \"presentingElement\", showBackdrop: \"showBackdrop\", translucent: \"translucent\", trigger: \"trigger\" }, queries: [{ propertyName: \"template\", first: true, predicate: TemplateRef, descendants: true }], ngImport: i0 });\n};\nIonModal = __decorate([\n    ProxyCmp({\n        inputs: MODAL_INPUTS,\n        methods: MODAL_METHODS,\n    })\n    /**\n     * @Component extends from @Directive\n     * so by defining the inputs here we\n     * do not need to re-define them for the\n     * lazy loaded popover.\n     */\n], IonModal);\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonModal, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'ion-modal',\n                    // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property\n                    inputs: MODAL_INPUTS,\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }]; }, propDecorators: { template: [{\n                type: ContentChild,\n                args: [TemplateRef, { static: false }]\n            }] } });\n\nconst insertView = (views, view, direction) => {\n    if (direction === 'root') {\n        return setRoot(views, view);\n    }\n    else if (direction === 'forward') {\n        return setForward(views, view);\n    }\n    else {\n        return setBack(views, view);\n    }\n};\nconst setRoot = (views, view) => {\n    views = views.filter((v) => v.stackId !== view.stackId);\n    views.push(view);\n    return views;\n};\nconst setForward = (views, view) => {\n    const index = views.indexOf(view);\n    if (index >= 0) {\n        views = views.filter((v) => v.stackId !== view.stackId || v.id <= view.id);\n    }\n    else {\n        views.push(view);\n    }\n    return views;\n};\nconst setBack = (views, view) => {\n    const index = views.indexOf(view);\n    if (index >= 0) {\n        return views.filter((v) => v.stackId !== view.stackId || v.id <= view.id);\n    }\n    else {\n        return setRoot(views, view);\n    }\n};\nconst getUrl = (router, activatedRoute) => {\n    const urlTree = router.createUrlTree(['.'], { relativeTo: activatedRoute });\n    return router.serializeUrl(urlTree);\n};\nconst isTabSwitch = (enteringView, leavingView) => {\n    if (!leavingView) {\n        return true;\n    }\n    return enteringView.stackId !== leavingView.stackId;\n};\nconst computeStackId = (prefixUrl, url) => {\n    if (!prefixUrl) {\n        return undefined;\n    }\n    const segments = toSegments(url);\n    for (let i = 0; i < segments.length; i++) {\n        if (i >= prefixUrl.length) {\n            return segments[i];\n        }\n        if (segments[i] !== prefixUrl[i]) {\n            return undefined;\n        }\n    }\n    return undefined;\n};\nconst toSegments = (path) => {\n    return path\n        .split('/')\n        .map((s) => s.trim())\n        .filter((s) => s !== '');\n};\nconst destroyView = (view) => {\n    if (view) {\n        view.ref.destroy();\n        view.unlistenEvents();\n    }\n};\n\n// TODO(FW-2827): types\nclass StackController {\n    containerEl;\n    router;\n    navCtrl;\n    zone;\n    location;\n    views = [];\n    runningTask;\n    skipTransition = false;\n    tabsPrefix;\n    activeView;\n    nextId = 0;\n    constructor(tabsPrefix, containerEl, router, navCtrl, zone, location) {\n        this.containerEl = containerEl;\n        this.router = router;\n        this.navCtrl = navCtrl;\n        this.zone = zone;\n        this.location = location;\n        this.tabsPrefix = tabsPrefix !== undefined ? toSegments(tabsPrefix) : undefined;\n    }\n    createView(ref, activatedRoute) {\n        const url = getUrl(this.router, activatedRoute);\n        const element = ref?.location?.nativeElement;\n        const unlistenEvents = bindLifecycleEvents(this.zone, ref.instance, element);\n        return {\n            id: this.nextId++,\n            stackId: computeStackId(this.tabsPrefix, url),\n            unlistenEvents,\n            element,\n            ref,\n            url,\n        };\n    }\n    getExistingView(activatedRoute) {\n        const activatedUrlKey = getUrl(this.router, activatedRoute);\n        const view = this.views.find((vw) => vw.url === activatedUrlKey);\n        if (view) {\n            view.ref.changeDetectorRef.reattach();\n        }\n        return view;\n    }\n    setActive(enteringView) {\n        const consumeResult = this.navCtrl.consumeTransition();\n        let { direction, animation, animationBuilder } = consumeResult;\n        const leavingView = this.activeView;\n        const tabSwitch = isTabSwitch(enteringView, leavingView);\n        if (tabSwitch) {\n            direction = 'back';\n            animation = undefined;\n        }\n        const viewsSnapshot = this.views.slice();\n        let currentNavigation;\n        const router = this.router;\n        // Angular >= 7.2.0\n        if (router.getCurrentNavigation) {\n            currentNavigation = router.getCurrentNavigation();\n            // Angular < 7.2.0\n        }\n        else if (router.navigations?.value) {\n            currentNavigation = router.navigations.value;\n        }\n        /**\n         * If the navigation action\n         * sets `replaceUrl: true`\n         * then we need to make sure\n         * we remove the last item\n         * from our views stack\n         */\n        if (currentNavigation?.extras?.replaceUrl) {\n            if (this.views.length > 0) {\n                this.views.splice(-1, 1);\n            }\n        }\n        const reused = this.views.includes(enteringView);\n        const views = this.insertView(enteringView, direction);\n        // Trigger change detection before transition starts\n        // This will call ngOnInit() the first time too, just after the view\n        // was attached to the dom, but BEFORE the transition starts\n        if (!reused) {\n            enteringView.ref.changeDetectorRef.detectChanges();\n        }\n        /**\n         * If we are going back from a page that\n         * was presented using a custom animation\n         * we should default to using that\n         * unless the developer explicitly\n         * provided another animation.\n         */\n        const customAnimation = enteringView.animationBuilder;\n        if (animationBuilder === undefined && direction === 'back' && !tabSwitch && customAnimation !== undefined) {\n            animationBuilder = customAnimation;\n        }\n        /**\n         * Save any custom animation so that navigating\n         * back will use this custom animation by default.\n         */\n        if (leavingView) {\n            leavingView.animationBuilder = animationBuilder;\n        }\n        // Wait until previous transitions finish\n        return this.zone.runOutsideAngular(() => {\n            return this.wait(() => {\n                // disconnect leaving page from change detection to\n                // reduce jank during the page transition\n                if (leavingView) {\n                    leavingView.ref.changeDetectorRef.detach();\n                }\n                // In case the enteringView is the same as the leavingPage we need to reattach()\n                enteringView.ref.changeDetectorRef.reattach();\n                return this.transition(enteringView, leavingView, animation, this.canGoBack(1), false, animationBuilder)\n                    .then(() => cleanupAsync(enteringView, views, viewsSnapshot, this.location, this.zone))\n                    .then(() => ({\n                    enteringView,\n                    direction,\n                    animation,\n                    tabSwitch,\n                }));\n            });\n        });\n    }\n    canGoBack(deep, stackId = this.getActiveStackId()) {\n        return this.getStack(stackId).length > deep;\n    }\n    pop(deep, stackId = this.getActiveStackId()) {\n        return this.zone.run(() => {\n            const views = this.getStack(stackId);\n            if (views.length <= deep) {\n                return Promise.resolve(false);\n            }\n            const view = views[views.length - deep - 1];\n            let url = view.url;\n            const viewSavedData = view.savedData;\n            if (viewSavedData) {\n                const primaryOutlet = viewSavedData.get('primary');\n                if (primaryOutlet?.route?._routerState?.snapshot.url) {\n                    url = primaryOutlet.route._routerState.snapshot.url;\n                }\n            }\n            const { animationBuilder } = this.navCtrl.consumeTransition();\n            return this.navCtrl.navigateBack(url, { ...view.savedExtras, animation: animationBuilder }).then(() => true);\n        });\n    }\n    startBackTransition() {\n        const leavingView = this.activeView;\n        if (leavingView) {\n            const views = this.getStack(leavingView.stackId);\n            const enteringView = views[views.length - 2];\n            const customAnimation = enteringView.animationBuilder;\n            return this.wait(() => {\n                return this.transition(enteringView, // entering view\n                leavingView, // leaving view\n                'back', this.canGoBack(2), true, customAnimation);\n            });\n        }\n        return Promise.resolve();\n    }\n    endBackTransition(shouldComplete) {\n        if (shouldComplete) {\n            this.skipTransition = true;\n            this.pop(1);\n        }\n        else if (this.activeView) {\n            cleanup(this.activeView, this.views, this.views, this.location, this.zone);\n        }\n    }\n    getLastUrl(stackId) {\n        const views = this.getStack(stackId);\n        return views.length > 0 ? views[views.length - 1] : undefined;\n    }\n    /**\n     * @internal\n     */\n    getRootUrl(stackId) {\n        const views = this.getStack(stackId);\n        return views.length > 0 ? views[0] : undefined;\n    }\n    getActiveStackId() {\n        return this.activeView ? this.activeView.stackId : undefined;\n    }\n    /**\n     * @internal\n     */\n    getActiveView() {\n        return this.activeView;\n    }\n    hasRunningTask() {\n        return this.runningTask !== undefined;\n    }\n    destroy() {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.containerEl = undefined;\n        this.views.forEach(destroyView);\n        this.activeView = undefined;\n        this.views = [];\n    }\n    getStack(stackId) {\n        return this.views.filter((v) => v.stackId === stackId);\n    }\n    insertView(enteringView, direction) {\n        this.activeView = enteringView;\n        this.views = insertView(this.views, enteringView, direction);\n        return this.views.slice();\n    }\n    transition(enteringView, leavingView, direction, showGoBack, progressAnimation, animationBuilder) {\n        if (this.skipTransition) {\n            this.skipTransition = false;\n            return Promise.resolve(false);\n        }\n        if (leavingView === enteringView) {\n            return Promise.resolve(false);\n        }\n        const enteringEl = enteringView ? enteringView.element : undefined;\n        const leavingEl = leavingView ? leavingView.element : undefined;\n        const containerEl = this.containerEl;\n        if (enteringEl && enteringEl !== leavingEl) {\n            enteringEl.classList.add('ion-page');\n            enteringEl.classList.add('ion-page-invisible');\n            if (containerEl.commit) {\n                return containerEl.commit(enteringEl, leavingEl, {\n                    duration: direction === undefined ? 0 : undefined,\n                    direction,\n                    showGoBack,\n                    progressAnimation,\n                    animationBuilder,\n                });\n            }\n        }\n        return Promise.resolve(false);\n    }\n    async wait(task) {\n        if (this.runningTask !== undefined) {\n            await this.runningTask;\n            this.runningTask = undefined;\n        }\n        const promise = (this.runningTask = task());\n        promise.finally(() => (this.runningTask = undefined));\n        return promise;\n    }\n}\nconst cleanupAsync = (activeRoute, views, viewsSnapshot, location, zone) => {\n    if (typeof requestAnimationFrame === 'function') {\n        return new Promise((resolve) => {\n            requestAnimationFrame(() => {\n                cleanup(activeRoute, views, viewsSnapshot, location, zone);\n                resolve();\n            });\n        });\n    }\n    return Promise.resolve();\n};\nconst cleanup = (activeRoute, views, viewsSnapshot, location, zone) => {\n    /**\n     * Re-enter the Angular zone when destroying page components. This will allow\n     * lifecycle events (`ngOnDestroy`) to be run inside the Angular zone.\n     */\n    zone.run(() => viewsSnapshot.filter((view) => !views.includes(view)).forEach(destroyView));\n    views.forEach((view) => {\n        /**\n         * In the event that a user navigated multiple\n         * times in rapid succession, we want to make sure\n         * we don't pre-emptively detach a view while\n         * it is in mid-transition.\n         *\n         * In this instance we also do not care about query\n         * params or fragments as it will be the same view regardless\n         */\n        const locationWithoutParams = location.path().split('?')[0];\n        const locationWithoutFragment = locationWithoutParams.split('#')[0];\n        if (view !== activeRoute && view.url !== locationWithoutFragment) {\n            const element = view.element;\n            element.setAttribute('aria-hidden', 'true');\n            element.classList.add('ion-page-hidden');\n            view.ref.changeDetectorRef.detach();\n        }\n    });\n};\n\n// TODO(FW-2827): types\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\nclass IonRouterOutlet {\n    parentOutlet;\n    nativeEl;\n    activatedView = null;\n    tabsPrefix;\n    _swipeGesture;\n    stackCtrl;\n    // Maintain map of activated route proxies for each component instance\n    proxyMap = new WeakMap();\n    // Keep the latest activated route in a subject for the proxy routes to switch map to\n    currentActivatedRoute$ = new BehaviorSubject(null);\n    activated = null;\n    /** @internal */\n    get activatedComponentRef() {\n        return this.activated;\n    }\n    _activatedRoute = null;\n    /**\n     * The name of the outlet\n     */\n    name = PRIMARY_OUTLET;\n    /** @internal */\n    stackWillChange = new EventEmitter();\n    /** @internal */\n    stackDidChange = new EventEmitter();\n    // eslint-disable-next-line @angular-eslint/no-output-rename\n    activateEvents = new EventEmitter();\n    // eslint-disable-next-line @angular-eslint/no-output-rename\n    deactivateEvents = new EventEmitter();\n    parentContexts = inject(ChildrenOutletContexts);\n    location = inject(ViewContainerRef);\n    environmentInjector = inject(EnvironmentInjector);\n    inputBinder = inject(INPUT_BINDER, { optional: true });\n    /** @nodoc */\n    supportsBindingToComponentInputs = true;\n    // Ionic providers\n    config = inject(Config);\n    navCtrl = inject(NavController);\n    set animation(animation) {\n        this.nativeEl.animation = animation;\n    }\n    set animated(animated) {\n        this.nativeEl.animated = animated;\n    }\n    set swipeGesture(swipe) {\n        this._swipeGesture = swipe;\n        this.nativeEl.swipeHandler = swipe\n            ? {\n                canStart: () => this.stackCtrl.canGoBack(1) && !this.stackCtrl.hasRunningTask(),\n                onStart: () => this.stackCtrl.startBackTransition(),\n                onEnd: (shouldContinue) => this.stackCtrl.endBackTransition(shouldContinue),\n            }\n            : undefined;\n    }\n    constructor(name, tabs, commonLocation, elementRef, router, zone, activatedRoute, parentOutlet) {\n        this.parentOutlet = parentOutlet;\n        this.nativeEl = elementRef.nativeElement;\n        this.name = name || PRIMARY_OUTLET;\n        this.tabsPrefix = tabs === 'true' ? getUrl(router, activatedRoute) : undefined;\n        this.stackCtrl = new StackController(this.tabsPrefix, this.nativeEl, router, this.navCtrl, zone, commonLocation);\n        this.parentContexts.onChildOutletCreated(this.name, this);\n    }\n    ngOnDestroy() {\n        this.stackCtrl.destroy();\n        this.inputBinder?.unsubscribeFromRouteData(this);\n    }\n    getContext() {\n        return this.parentContexts.getContext(this.name);\n    }\n    ngOnInit() {\n        this.initializeOutletWithName();\n    }\n    // Note: Ionic deviates from the Angular Router implementation here\n    initializeOutletWithName() {\n        if (!this.activated) {\n            // If the outlet was not instantiated at the time the route got activated we need to populate\n            // the outlet when it is initialized (ie inside a NgIf)\n            const context = this.getContext();\n            if (context?.route) {\n                this.activateWith(context.route, context.injector);\n            }\n        }\n        new Promise((resolve) => componentOnReady(this.nativeEl, resolve)).then(() => {\n            if (this._swipeGesture === undefined) {\n                this.swipeGesture = this.config.getBoolean('swipeBackEnabled', this.nativeEl.mode === 'ios');\n            }\n        });\n    }\n    get isActivated() {\n        return !!this.activated;\n    }\n    get component() {\n        if (!this.activated) {\n            throw new Error('Outlet is not activated');\n        }\n        return this.activated.instance;\n    }\n    get activatedRoute() {\n        if (!this.activated) {\n            throw new Error('Outlet is not activated');\n        }\n        return this._activatedRoute;\n    }\n    get activatedRouteData() {\n        if (this._activatedRoute) {\n            return this._activatedRoute.snapshot.data;\n        }\n        return {};\n    }\n    /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     */\n    detach() {\n        throw new Error('incompatible reuse strategy');\n    }\n    /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    attach(_ref, _activatedRoute) {\n        throw new Error('incompatible reuse strategy');\n    }\n    deactivate() {\n        if (this.activated) {\n            if (this.activatedView) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const context = this.getContext();\n                this.activatedView.savedData = new Map(context.children['contexts']);\n                /**\n                 * Angular v11.2.10 introduced a change\n                 * where this route context is cleared out when\n                 * a router-outlet is deactivated, However,\n                 * we need this route information in order to\n                 * return a user back to the correct tab when\n                 * leaving and then going back to the tab context.\n                 */\n                const primaryOutlet = this.activatedView.savedData.get('primary');\n                if (primaryOutlet && context.route) {\n                    primaryOutlet.route = { ...context.route };\n                }\n                /**\n                 * Ensure we are saving the NavigationExtras\n                 * data otherwise it will be lost\n                 */\n                this.activatedView.savedExtras = {};\n                if (context.route) {\n                    const contextSnapshot = context.route.snapshot;\n                    this.activatedView.savedExtras.queryParams = contextSnapshot.queryParams;\n                    this.activatedView.savedExtras.fragment = contextSnapshot.fragment;\n                }\n            }\n            const c = this.component;\n            this.activatedView = null;\n            this.activated = null;\n            this._activatedRoute = null;\n            this.deactivateEvents.emit(c);\n        }\n    }\n    activateWith(activatedRoute, environmentInjector) {\n        if (this.isActivated) {\n            throw new Error('Cannot activate an already activated outlet');\n        }\n        this._activatedRoute = activatedRoute;\n        let cmpRef;\n        let enteringView = this.stackCtrl.getExistingView(activatedRoute);\n        if (enteringView) {\n            cmpRef = this.activated = enteringView.ref;\n            const saved = enteringView.savedData;\n            if (saved) {\n                // self-restore\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const context = this.getContext();\n                context.children['contexts'] = saved;\n            }\n            // Updated activated route proxy for this component\n            this.updateActivatedRouteProxy(cmpRef.instance, activatedRoute);\n        }\n        else {\n            const snapshot = activatedRoute._futureSnapshot;\n            /**\n             * Angular 14 introduces a new `loadComponent` property to the route config.\n             * This function will assign a `component` property to the route snapshot.\n             * We check for the presence of this property to determine if the route is\n             * using standalone components.\n             */\n            const childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n            // We create an activated route proxy object that will maintain future updates for this component\n            // over its lifecycle in the stack.\n            const component$ = new BehaviorSubject(null);\n            const activatedRouteProxy = this.createActivatedRouteProxy(component$, activatedRoute);\n            const injector = new OutletInjector(activatedRouteProxy, childContexts, this.location.injector);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const component = snapshot.routeConfig.component ?? snapshot.component;\n            /**\n             * View components need to be added as a child of ion-router-outlet\n             * for page transitions and swipe to go back.\n             * However, createComponent mounts components as siblings of the\n             * ViewContainerRef. As a result, outletContent must reference\n             * an ng-container inside of ion-router-outlet and not\n             * ion-router-outlet itself.\n             */\n            cmpRef = this.activated = this.outletContent.createComponent(component, {\n                index: this.outletContent.length,\n                injector,\n                environmentInjector: environmentInjector ?? this.environmentInjector,\n            });\n            // Once the component is created we can push it to our local subject supplied to the proxy\n            component$.next(cmpRef.instance);\n            // Calling `markForCheck` to make sure we will run the change detection when the\n            // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n            /**\n             * At this point this.activated has been set earlier\n             * in this function, so it is guaranteed to be non-null.\n             */\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            enteringView = this.stackCtrl.createView(this.activated, activatedRoute);\n            // Store references to the proxy by component\n            this.proxyMap.set(cmpRef.instance, activatedRouteProxy);\n            this.currentActivatedRoute$.next({ component: cmpRef.instance, activatedRoute });\n        }\n        this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n        this.activatedView = enteringView;\n        /**\n         * The top outlet is set prior to the entering view's transition completing,\n         * so that when we have nested outlets (e.g. ion-tabs inside an ion-router-outlet),\n         * the tabs outlet will be assigned as the top outlet when a view inside tabs is\n         * activated.\n         *\n         * In this scenario, activeWith is called for both the tabs and the root router outlet.\n         * To avoid a race condition, we assign the top outlet synchronously.\n         */\n        this.navCtrl.setTopOutlet(this);\n        const leavingView = this.stackCtrl.getActiveView();\n        this.stackWillChange.emit({\n            enteringView,\n            tabSwitch: isTabSwitch(enteringView, leavingView),\n        });\n        this.stackCtrl.setActive(enteringView).then((data) => {\n            this.activateEvents.emit(cmpRef.instance);\n            this.stackDidChange.emit(data);\n        });\n    }\n    /**\n     * Returns `true` if there are pages in the stack to go back.\n     */\n    canGoBack(deep = 1, stackId) {\n        return this.stackCtrl.canGoBack(deep, stackId);\n    }\n    /**\n     * Resolves to `true` if it the outlet was able to sucessfully pop the last N pages.\n     */\n    pop(deep = 1, stackId) {\n        return this.stackCtrl.pop(deep, stackId);\n    }\n    /**\n     * Returns the URL of the active page of each stack.\n     */\n    getLastUrl(stackId) {\n        const active = this.stackCtrl.getLastUrl(stackId);\n        return active ? active.url : undefined;\n    }\n    /**\n     * Returns the RouteView of the active page of each stack.\n     * @internal\n     */\n    getLastRouteView(stackId) {\n        return this.stackCtrl.getLastUrl(stackId);\n    }\n    /**\n     * Returns the root view in the tab stack.\n     * @internal\n     */\n    getRootView(stackId) {\n        return this.stackCtrl.getRootUrl(stackId);\n    }\n    /**\n     * Returns the active stack ID. In the context of ion-tabs, it means the active tab.\n     */\n    getActiveStackId() {\n        return this.stackCtrl.getActiveStackId();\n    }\n    /**\n     * Since the activated route can change over the life time of a component in an ion router outlet, we create\n     * a proxy so that we can update the values over time as a user navigates back to components already in the stack.\n     */\n    createActivatedRouteProxy(component$, activatedRoute) {\n        const proxy = new ActivatedRoute();\n        proxy._futureSnapshot = activatedRoute._futureSnapshot;\n        proxy._routerState = activatedRoute._routerState;\n        proxy.snapshot = activatedRoute.snapshot;\n        proxy.outlet = activatedRoute.outlet;\n        proxy.component = activatedRoute.component;\n        // Setup wrappers for the observables so consumers don't have to worry about switching to new observables as the state updates\n        proxy._paramMap = this.proxyObservable(component$, 'paramMap');\n        proxy._queryParamMap = this.proxyObservable(component$, 'queryParamMap');\n        proxy.url = this.proxyObservable(component$, 'url');\n        proxy.params = this.proxyObservable(component$, 'params');\n        proxy.queryParams = this.proxyObservable(component$, 'queryParams');\n        proxy.fragment = this.proxyObservable(component$, 'fragment');\n        proxy.data = this.proxyObservable(component$, 'data');\n        return proxy;\n    }\n    /**\n     * Create a wrapped observable that will switch to the latest activated route matched by the given component\n     */\n    proxyObservable(component$, path) {\n        return component$.pipe(\n        // First wait until the component instance is pushed\n        filter((component) => !!component), switchMap((component) => this.currentActivatedRoute$.pipe(filter((current) => current !== null && current.component === component), switchMap((current) => current && current.activatedRoute[path]), distinctUntilChanged())));\n    }\n    /**\n     * Updates the activated route proxy for the given component to the new incoming router state\n     */\n    updateActivatedRouteProxy(component, activatedRoute) {\n        const proxy = this.proxyMap.get(component);\n        if (!proxy) {\n            throw new Error(`Could not find activated route proxy for view`);\n        }\n        proxy._futureSnapshot = activatedRoute._futureSnapshot;\n        proxy._routerState = activatedRoute._routerState;\n        proxy.snapshot = activatedRoute.snapshot;\n        proxy.outlet = activatedRoute.outlet;\n        proxy.component = activatedRoute.component;\n        this.currentActivatedRoute$.next({ component, activatedRoute });\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonRouterOutlet, deps: [{ token: 'name', attribute: true }, { token: 'tabs', attribute: true, optional: true }, { token: i1.Location }, { token: i0.ElementRef }, { token: i3.Router }, { token: i0.NgZone }, { token: i3.ActivatedRoute }, { token: IonRouterOutlet, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.Directive });\n    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.12\", type: IonRouterOutlet, selector: \"ion-router-outlet\", inputs: { animated: \"animated\", animation: \"animation\", mode: \"mode\", swipeGesture: \"swipeGesture\", name: \"name\" }, outputs: { stackWillChange: \"stackWillChange\", stackDidChange: \"stackDidChange\", activateEvents: \"activate\", deactivateEvents: \"deactivate\" }, exportAs: [\"outlet\"], ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonRouterOutlet, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'ion-router-outlet',\n                    exportAs: 'outlet',\n                    // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property\n                    inputs: ['animated', 'animation', 'mode', 'swipeGesture'],\n                }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Attribute,\n                    args: ['name']\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Attribute,\n                    args: ['tabs']\n                }] }, { type: i1.Location }, { type: i0.ElementRef }, { type: i3.Router }, { type: i0.NgZone }, { type: i3.ActivatedRoute }, { type: IonRouterOutlet, decorators: [{\n                    type: SkipSelf\n                }, {\n                    type: Optional\n                }] }]; }, propDecorators: { name: [{\n                type: Input\n            }], stackWillChange: [{\n                type: Output\n            }], stackDidChange: [{\n                type: Output\n            }], activateEvents: [{\n                type: Output,\n                args: ['activate']\n            }], deactivateEvents: [{\n                type: Output,\n                args: ['deactivate']\n            }] } });\nclass OutletInjector {\n    route;\n    childContexts;\n    parent;\n    constructor(route, childContexts, parent) {\n        this.route = route;\n        this.childContexts = childContexts;\n        this.parent = parent;\n    }\n    get(token, notFoundValue) {\n        if (token === ActivatedRoute) {\n            return this.route;\n        }\n        if (token === ChildrenOutletContexts) {\n            return this.childContexts;\n        }\n        return this.parent.get(token, notFoundValue);\n    }\n}\n// TODO: FW-4785 - Remove this once Angular 15 support is dropped\nconst INPUT_BINDER = new InjectionToken('');\n/**\n * Injectable used as a tree-shakable provider for opting in to binding router data to component\n * inputs.\n *\n * The RouterOutlet registers itself with this service when an `ActivatedRoute` is attached or\n * activated. When this happens, the service subscribes to the `ActivatedRoute` observables (params,\n * queryParams, data) and sets the inputs of the component using `ComponentRef.setInput`.\n * Importantly, when an input does not have an item in the route data with a matching key, this\n * input is set to `undefined`. If it were not done this way, the previous information would be\n * retained if the data got removed from the route (i.e. if a query parameter is removed).\n *\n * The `RouterOutlet` should unregister itself when destroyed via `unsubscribeFromRouteData` so that\n * the subscriptions are cleaned up.\n */\nclass RoutedComponentInputBinder {\n    outletDataSubscriptions = new Map();\n    bindActivatedRouteToOutletComponent(outlet) {\n        this.unsubscribeFromRouteData(outlet);\n        this.subscribeToRouteData(outlet);\n    }\n    unsubscribeFromRouteData(outlet) {\n        this.outletDataSubscriptions.get(outlet)?.unsubscribe();\n        this.outletDataSubscriptions.delete(outlet);\n    }\n    subscribeToRouteData(outlet) {\n        const { activatedRoute } = outlet;\n        const dataSubscription = combineLatest([activatedRoute.queryParams, activatedRoute.params, activatedRoute.data])\n            .pipe(switchMap(([queryParams, params, data], index) => {\n            data = { ...queryParams, ...params, ...data };\n            // Get the first result from the data subscription synchronously so it's available to\n            // the component as soon as possible (and doesn't require a second change detection).\n            if (index === 0) {\n                return of(data);\n            }\n            // Promise.resolve is used to avoid synchronously writing the wrong data when\n            // two of the Observables in the `combineLatest` stream emit one after\n            // another.\n            return Promise.resolve(data);\n        }))\n            .subscribe((data) => {\n            // Outlet may have been deactivated or changed names to be associated with a different\n            // route\n            if (!outlet.isActivated ||\n                !outlet.activatedComponentRef ||\n                outlet.activatedRoute !== activatedRoute ||\n                activatedRoute.component === null) {\n                this.unsubscribeFromRouteData(outlet);\n                return;\n            }\n            const mirror = reflectComponentType(activatedRoute.component);\n            if (!mirror) {\n                this.unsubscribeFromRouteData(outlet);\n                return;\n            }\n            for (const { templateName } of mirror.inputs) {\n                outlet.activatedComponentRef.setInput(templateName, data[templateName]);\n            }\n        });\n        this.outletDataSubscriptions.set(outlet, dataSubscription);\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: RoutedComponentInputBinder, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: RoutedComponentInputBinder });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: RoutedComponentInputBinder, decorators: [{\n            type: Injectable\n        }] });\nconst provideComponentInputBinding = () => {\n    return {\n        provide: INPUT_BINDER,\n        useFactory: componentInputBindingFactory,\n        deps: [Router],\n    };\n};\nfunction componentInputBindingFactory(router) {\n    /**\n     * We cast the router to any here, since the componentInputBindingEnabled\n     * property is not available until Angular v16.\n     */\n    if (router?.componentInputBindingEnabled) {\n        return new RoutedComponentInputBinder();\n    }\n    return null;\n}\n\nconst BACK_BUTTON_INPUTS = ['color', 'defaultHref', 'disabled', 'icon', 'mode', 'routerAnimation', 'text', 'type'];\nlet IonBackButton = class IonBackButton {\n    routerOutlet;\n    navCtrl;\n    config;\n    r;\n    z;\n    el;\n    constructor(routerOutlet, navCtrl, config, r, z, c) {\n        this.routerOutlet = routerOutlet;\n        this.navCtrl = navCtrl;\n        this.config = config;\n        this.r = r;\n        this.z = z;\n        c.detach();\n        this.el = this.r.nativeElement;\n    }\n    /**\n     * @internal\n     */\n    onClick(ev) {\n        const defaultHref = this.defaultHref || this.config.get('backButtonDefaultHref');\n        if (this.routerOutlet?.canGoBack()) {\n            this.navCtrl.setDirection('back', undefined, undefined, this.routerAnimation);\n            this.routerOutlet.pop();\n            ev.preventDefault();\n        }\n        else if (defaultHref != null) {\n            this.navCtrl.navigateBack(defaultHref, { animation: this.routerAnimation });\n            ev.preventDefault();\n        }\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonBackButton, deps: [{ token: IonRouterOutlet, optional: true }, { token: NavController }, { token: Config }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });\n    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.12\", type: IonBackButton, inputs: { color: \"color\", defaultHref: \"defaultHref\", disabled: \"disabled\", icon: \"icon\", mode: \"mode\", routerAnimation: \"routerAnimation\", text: \"text\", type: \"type\" }, host: { listeners: { \"click\": \"onClick($event)\" } }, ngImport: i0 });\n};\nIonBackButton = __decorate([\n    ProxyCmp({\n        inputs: BACK_BUTTON_INPUTS,\n    })\n], IonBackButton);\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonBackButton, decorators: [{\n            type: Directive,\n            args: [{\n                    // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property\n                    inputs: BACK_BUTTON_INPUTS,\n                }]\n        }], ctorParameters: function () { return [{ type: IonRouterOutlet, decorators: [{\n                    type: Optional\n                }] }, { type: NavController }, { type: Config }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { onClick: [{\n                type: HostListener,\n                args: ['click', ['$event']]\n            }] } });\n\n/**\n * Adds support for Ionic routing directions and animations to the base Angular router link directive.\n *\n * When the router link is clicked, the directive will assign the direction and\n * animation so that the routing integration will transition correctly.\n */\nclass RouterLinkDelegateDirective {\n    locationStrategy;\n    navCtrl;\n    elementRef;\n    router;\n    routerLink;\n    routerDirection = 'forward';\n    routerAnimation;\n    constructor(locationStrategy, navCtrl, elementRef, router, routerLink) {\n        this.locationStrategy = locationStrategy;\n        this.navCtrl = navCtrl;\n        this.elementRef = elementRef;\n        this.router = router;\n        this.routerLink = routerLink;\n    }\n    ngOnInit() {\n        this.updateTargetUrlAndHref();\n        this.updateTabindex();\n    }\n    ngOnChanges() {\n        this.updateTargetUrlAndHref();\n    }\n    /**\n     * The `tabindex` is set to `0` by default on the host element when\n     * the `routerLink` directive is used. This causes issues with Ionic\n     * components that wrap an `a` or `button` element, such as `ion-item`.\n     * See issue https://github.com/angular/angular/issues/28345\n     *\n     * This method removes the `tabindex` attribute from the host element\n     * to allow the Ionic component to manage the focus state correctly.\n     */\n    updateTabindex() {\n        // Ionic components that render a native anchor or button element\n        const ionicComponents = [\n            'ION-BACK-BUTTON',\n            'ION-BREADCRUMB',\n            'ION-BUTTON',\n            'ION-CARD',\n            'ION-FAB-BUTTON',\n            'ION-ITEM',\n            'ION-ITEM-OPTION',\n            'ION-MENU-BUTTON',\n            'ION-SEGMENT-BUTTON',\n            'ION-TAB-BUTTON',\n        ];\n        const hostElement = this.elementRef.nativeElement;\n        if (ionicComponents.includes(hostElement.tagName)) {\n            if (hostElement.getAttribute('tabindex') === '0') {\n                hostElement.removeAttribute('tabindex');\n            }\n        }\n    }\n    updateTargetUrlAndHref() {\n        if (this.routerLink?.urlTree) {\n            const href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.routerLink.urlTree));\n            this.elementRef.nativeElement.href = href;\n        }\n    }\n    /**\n     * @internal\n     */\n    onClick(ev) {\n        this.navCtrl.setDirection(this.routerDirection, undefined, undefined, this.routerAnimation);\n        /**\n         * This prevents the browser from\n         * performing a page reload when pressing\n         * an Ionic component with routerLink.\n         * The page reload interferes with routing\n         * and causes ion-back-button to disappear\n         * since the local history is wiped on reload.\n         */\n        ev.preventDefault();\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: RouterLinkDelegateDirective, deps: [{ token: i1.LocationStrategy }, { token: NavController }, { token: i0.ElementRef }, { token: i3.Router }, { token: i3.RouterLink, optional: true }], target: i0.ɵɵFactoryTarget.Directive });\n    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.12\", type: RouterLinkDelegateDirective, selector: \":not(a):not(area)[routerLink]\", inputs: { routerDirection: \"routerDirection\", routerAnimation: \"routerAnimation\" }, host: { listeners: { \"click\": \"onClick($event)\" } }, usesOnChanges: true, ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: RouterLinkDelegateDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: ':not(a):not(area)[routerLink]',\n                }]\n        }], ctorParameters: function () { return [{ type: i1.LocationStrategy }, { type: NavController }, { type: i0.ElementRef }, { type: i3.Router }, { type: i3.RouterLink, decorators: [{\n                    type: Optional\n                }] }]; }, propDecorators: { routerDirection: [{\n                type: Input\n            }], routerAnimation: [{\n                type: Input\n            }], onClick: [{\n                type: HostListener,\n                args: ['click', ['$event']]\n            }] } });\nclass RouterLinkWithHrefDelegateDirective {\n    locationStrategy;\n    navCtrl;\n    elementRef;\n    router;\n    routerLink;\n    routerDirection = 'forward';\n    routerAnimation;\n    constructor(locationStrategy, navCtrl, elementRef, router, routerLink) {\n        this.locationStrategy = locationStrategy;\n        this.navCtrl = navCtrl;\n        this.elementRef = elementRef;\n        this.router = router;\n        this.routerLink = routerLink;\n    }\n    ngOnInit() {\n        this.updateTargetUrlAndHref();\n    }\n    ngOnChanges() {\n        this.updateTargetUrlAndHref();\n    }\n    updateTargetUrlAndHref() {\n        if (this.routerLink?.urlTree) {\n            const href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.routerLink.urlTree));\n            this.elementRef.nativeElement.href = href;\n        }\n    }\n    /**\n     * @internal\n     */\n    onClick() {\n        this.navCtrl.setDirection(this.routerDirection, undefined, undefined, this.routerAnimation);\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: RouterLinkWithHrefDelegateDirective, deps: [{ token: i1.LocationStrategy }, { token: NavController }, { token: i0.ElementRef }, { token: i3.Router }, { token: i3.RouterLink, optional: true }], target: i0.ɵɵFactoryTarget.Directive });\n    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.12\", type: RouterLinkWithHrefDelegateDirective, selector: \"a[routerLink],area[routerLink]\", inputs: { routerDirection: \"routerDirection\", routerAnimation: \"routerAnimation\" }, host: { listeners: { \"click\": \"onClick()\" } }, usesOnChanges: true, ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: RouterLinkWithHrefDelegateDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'a[routerLink],area[routerLink]',\n                }]\n        }], ctorParameters: function () { return [{ type: i1.LocationStrategy }, { type: NavController }, { type: i0.ElementRef }, { type: i3.Router }, { type: i3.RouterLink, decorators: [{\n                    type: Optional\n                }] }]; }, propDecorators: { routerDirection: [{\n                type: Input\n            }], routerAnimation: [{\n                type: Input\n            }], onClick: [{\n                type: HostListener,\n                args: ['click']\n            }] } });\n\nconst NAV_INPUTS = ['animated', 'animation', 'root', 'rootParams', 'swipeGesture'];\nconst NAV_METHODS = [\n    'push',\n    'insert',\n    'insertPages',\n    'pop',\n    'popTo',\n    'popToRoot',\n    'removeIndex',\n    'setRoot',\n    'setPages',\n    'getActive',\n    'getByIndex',\n    'canGoBack',\n    'getPrevious',\n];\nlet IonNav = class IonNav {\n    z;\n    el;\n    constructor(ref, environmentInjector, injector, angularDelegate, z, c) {\n        this.z = z;\n        c.detach();\n        this.el = ref.nativeElement;\n        ref.nativeElement.delegate = angularDelegate.create(environmentInjector, injector);\n        proxyOutputs(this, this.el, ['ionNavDidChange', 'ionNavWillChange']);\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonNav, deps: [{ token: i0.ElementRef }, { token: i0.EnvironmentInjector }, { token: i0.Injector }, { token: AngularDelegate }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });\n    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.12\", type: IonNav, inputs: { animated: \"animated\", animation: \"animation\", root: \"root\", rootParams: \"rootParams\", swipeGesture: \"swipeGesture\" }, ngImport: i0 });\n};\nIonNav = __decorate([\n    ProxyCmp({\n        inputs: NAV_INPUTS,\n        methods: NAV_METHODS,\n    })\n], IonNav);\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonNav, decorators: [{\n            type: Directive,\n            args: [{\n                    // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property\n                    inputs: NAV_INPUTS,\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.EnvironmentInjector }, { type: i0.Injector }, { type: AngularDelegate }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }]; } });\n\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\nclass IonTabs {\n    navCtrl;\n    tabsInner;\n    /**\n     * Emitted before the tab view is changed.\n     */\n    ionTabsWillChange = new EventEmitter();\n    /**\n     * Emitted after the tab view is changed.\n     */\n    ionTabsDidChange = new EventEmitter();\n    tabBarSlot = 'bottom';\n    hasTab = false;\n    selectedTab;\n    leavingTab;\n    constructor(navCtrl) {\n        this.navCtrl = navCtrl;\n    }\n    ngAfterViewInit() {\n        /**\n         * Developers must pass at least one ion-tab\n         * inside of ion-tabs if they want to use a\n         * basic tab-based navigation without the\n         * history stack or URL updates associated\n         * with the router.\n         */\n        const firstTab = this.tabs.length > 0 ? this.tabs.first : undefined;\n        if (firstTab) {\n            this.hasTab = true;\n            this.setActiveTab(firstTab.tab);\n            this.tabSwitch();\n        }\n    }\n    ngAfterContentInit() {\n        this.detectSlotChanges();\n    }\n    ngAfterContentChecked() {\n        this.detectSlotChanges();\n    }\n    /**\n     * @internal\n     */\n    onStackWillChange({ enteringView, tabSwitch }) {\n        const stackId = enteringView.stackId;\n        if (tabSwitch && stackId !== undefined) {\n            this.ionTabsWillChange.emit({ tab: stackId });\n        }\n    }\n    /**\n     * @internal\n     */\n    onStackDidChange({ enteringView, tabSwitch }) {\n        const stackId = enteringView.stackId;\n        if (tabSwitch && stackId !== undefined) {\n            if (this.tabBar) {\n                this.tabBar.selectedTab = stackId;\n            }\n            this.ionTabsDidChange.emit({ tab: stackId });\n        }\n    }\n    /**\n     * When a tab button is clicked, there are several scenarios:\n     * 1. If the selected tab is currently active (the tab button has been clicked\n     *    again), then it should go to the root view for that tab.\n     *\n     *   a. Get the saved root view from the router outlet. If the saved root view\n     *      matches the tabRootUrl, set the route view to this view including the\n     *      navigation extras.\n     *   b. If the saved root view from the router outlet does\n     *      not match, navigate to the tabRootUrl. No navigation extras are\n     *      included.\n     *\n     * 2. If the current tab tab is not currently selected, get the last route\n     *    view from the router outlet.\n     *\n     *   a. If the last route view exists, navigate to that view including any\n     *      navigation extras\n     *   b. If the last route view doesn't exist, then navigate\n     *      to the default tabRootUrl\n     */\n    select(tabOrEvent) {\n        const isTabString = typeof tabOrEvent === 'string';\n        const tab = isTabString ? tabOrEvent : tabOrEvent.detail.tab;\n        /**\n         * If the tabs are not using the router, then\n         * the tab switch logic is handled by the tabs\n         * component itself.\n         */\n        if (this.hasTab) {\n            this.setActiveTab(tab);\n            this.tabSwitch();\n            return;\n        }\n        const alreadySelected = this.outlet.getActiveStackId() === tab;\n        const tabRootUrl = `${this.outlet.tabsPrefix}/${tab}`;\n        /**\n         * If this is a nested tab, prevent the event\n         * from bubbling otherwise the outer tabs\n         * will respond to this event too, causing\n         * the app to get directed to the wrong place.\n         */\n        if (!isTabString) {\n            tabOrEvent.stopPropagation();\n        }\n        if (alreadySelected) {\n            const activeStackId = this.outlet.getActiveStackId();\n            const activeView = this.outlet.getLastRouteView(activeStackId);\n            // If on root tab, do not navigate to root tab again\n            if (activeView?.url === tabRootUrl) {\n                return;\n            }\n            const rootView = this.outlet.getRootView(tab);\n            const navigationExtras = rootView && tabRootUrl === rootView.url && rootView.savedExtras;\n            return this.navCtrl.navigateRoot(tabRootUrl, {\n                ...navigationExtras,\n                animated: true,\n                animationDirection: 'back',\n            });\n        }\n        else {\n            const lastRoute = this.outlet.getLastRouteView(tab);\n            /**\n             * If there is a lastRoute, goto that, otherwise goto the fallback url of the\n             * selected tab\n             */\n            const url = lastRoute?.url || tabRootUrl;\n            const navigationExtras = lastRoute?.savedExtras;\n            return this.navCtrl.navigateRoot(url, {\n                ...navigationExtras,\n                animated: true,\n                animationDirection: 'back',\n            });\n        }\n    }\n    setActiveTab(tab) {\n        const tabs = this.tabs;\n        const selectedTab = tabs.find((t) => t.tab === tab);\n        if (!selectedTab) {\n            console.error(`[Ionic Error]: Tab with id: \"${tab}\" does not exist`);\n            return;\n        }\n        this.leavingTab = this.selectedTab;\n        this.selectedTab = selectedTab;\n        this.ionTabsWillChange.emit({ tab });\n        selectedTab.el.active = true;\n    }\n    tabSwitch() {\n        const { selectedTab, leavingTab } = this;\n        if (this.tabBar && selectedTab) {\n            this.tabBar.selectedTab = selectedTab.tab;\n        }\n        if (leavingTab?.tab !== selectedTab?.tab) {\n            if (leavingTab?.el) {\n                leavingTab.el.active = false;\n            }\n        }\n        if (selectedTab) {\n            this.ionTabsDidChange.emit({ tab: selectedTab.tab });\n        }\n    }\n    getSelected() {\n        if (this.hasTab) {\n            return this.selectedTab?.tab;\n        }\n        return this.outlet.getActiveStackId();\n    }\n    /**\n     * Detects changes to the slot attribute of the tab bar.\n     *\n     * If the slot attribute has changed, then the tab bar\n     * should be relocated to the new slot position.\n     */\n    detectSlotChanges() {\n        this.tabBars.forEach((tabBar) => {\n            // el is a protected attribute from the generated component wrapper\n            const currentSlot = tabBar.el.getAttribute('slot');\n            if (currentSlot !== this.tabBarSlot) {\n                this.tabBarSlot = currentSlot;\n                this.relocateTabBar();\n            }\n        });\n    }\n    /**\n     * Relocates the tab bar to the new slot position.\n     */\n    relocateTabBar() {\n        /**\n         * `el` is a protected attribute from the generated component wrapper.\n         * To avoid having to manually create the wrapper for tab bar, we\n         * cast the tab bar to any and access the protected attribute.\n         */\n        const tabBar = this.tabBar.el;\n        if (this.tabBarSlot === 'top') {\n            /**\n             * A tab bar with a slot of \"top\" should be inserted\n             * at the top of the container.\n             */\n            this.tabsInner.nativeElement.before(tabBar);\n        }\n        else {\n            /**\n             * A tab bar with a slot of \"bottom\" or without a slot\n             * should be inserted at the end of the container.\n             */\n            this.tabsInner.nativeElement.after(tabBar);\n        }\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonTabs, deps: [{ token: NavController }], target: i0.ɵɵFactoryTarget.Directive });\n    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.12\", type: IonTabs, selector: \"ion-tabs\", outputs: { ionTabsWillChange: \"ionTabsWillChange\", ionTabsDidChange: \"ionTabsDidChange\" }, host: { listeners: { \"ionTabButtonClick\": \"select($event)\" } }, viewQueries: [{ propertyName: \"tabsInner\", first: true, predicate: [\"tabsInner\"], descendants: true, read: ElementRef, static: true }], ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonTabs, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'ion-tabs',\n                }]\n        }], ctorParameters: function () { return [{ type: NavController }]; }, propDecorators: { tabsInner: [{\n                type: ViewChild,\n                args: ['tabsInner', { read: ElementRef, static: true }]\n            }], ionTabsWillChange: [{\n                type: Output\n            }], ionTabsDidChange: [{\n                type: Output\n            }], select: [{\n                type: HostListener,\n                args: ['ionTabButtonClick', ['$event']]\n            }] } });\n\nconst raf = (h) => {\n    if (typeof __zone_symbol__requestAnimationFrame === 'function') {\n        return __zone_symbol__requestAnimationFrame(h);\n    }\n    if (typeof requestAnimationFrame === 'function') {\n        return requestAnimationFrame(h);\n    }\n    return setTimeout(h);\n};\n\n// TODO(FW-2827): types\nclass ValueAccessor {\n    injector;\n    elementRef;\n    onChange = () => {\n        /**/\n    };\n    onTouched = () => {\n        /**/\n    };\n    lastValue;\n    statusChanges;\n    constructor(injector, elementRef) {\n        this.injector = injector;\n        this.elementRef = elementRef;\n    }\n    writeValue(value) {\n        this.elementRef.nativeElement.value = this.lastValue = value;\n        setIonicClasses(this.elementRef);\n    }\n    /**\n     * Notifies the ControlValueAccessor of a change in the value of the control.\n     *\n     * This is called by each of the ValueAccessor directives when we want to update\n     * the status and validity of the form control. For example with text components this\n     * is called when the ionInput event is fired. For select components this is called\n     * when the ionChange event is fired.\n     *\n     * This also updates the Ionic form status classes on the element.\n     *\n     * @param el The component element.\n     * @param value The new value of the control.\n     */\n    handleValueChange(el, value) {\n        if (el === this.elementRef.nativeElement) {\n            if (value !== this.lastValue) {\n                this.lastValue = value;\n                this.onChange(value);\n            }\n            setIonicClasses(this.elementRef);\n        }\n    }\n    _handleBlurEvent(el) {\n        if (el === this.elementRef.nativeElement) {\n            this.onTouched();\n            setIonicClasses(this.elementRef);\n        }\n    }\n    registerOnChange(fn) {\n        this.onChange = fn;\n    }\n    registerOnTouched(fn) {\n        this.onTouched = fn;\n    }\n    setDisabledState(isDisabled) {\n        this.elementRef.nativeElement.disabled = isDisabled;\n    }\n    ngOnDestroy() {\n        if (this.statusChanges) {\n            this.statusChanges.unsubscribe();\n        }\n    }\n    ngAfterViewInit() {\n        let ngControl;\n        try {\n            ngControl = this.injector.get(NgControl);\n        }\n        catch {\n            /* No FormControl or ngModel binding */\n        }\n        if (!ngControl) {\n            return;\n        }\n        // Listen for changes in validity, disabled, or pending states\n        if (ngControl.statusChanges) {\n            this.statusChanges = ngControl.statusChanges.subscribe(() => setIonicClasses(this.elementRef));\n        }\n        /**\n         * TODO FW-2787: Remove this in favor of https://github.com/angular/angular/issues/10887\n         * whenever it is implemented.\n         */\n        const formControl = ngControl.control;\n        if (formControl) {\n            const methodsToPatch = ['markAsTouched', 'markAllAsTouched', 'markAsUntouched', 'markAsDirty', 'markAsPristine'];\n            methodsToPatch.forEach((method) => {\n                if (typeof formControl[method] !== 'undefined') {\n                    const oldFn = formControl[method].bind(formControl);\n                    formControl[method] = (...params) => {\n                        oldFn(...params);\n                        setIonicClasses(this.elementRef);\n                    };\n                }\n            });\n        }\n    }\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: ValueAccessor, deps: [{ token: i0.Injector }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });\n    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.12\", type: ValueAccessor, host: { listeners: { \"ionBlur\": \"_handleBlurEvent($event.target)\" } }, ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: ValueAccessor, decorators: [{\n            type: Directive\n        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i0.ElementRef }]; }, propDecorators: { _handleBlurEvent: [{\n                type: HostListener,\n                args: ['ionBlur', ['$event.target']]\n            }] } });\nconst setIonicClasses = (element) => {\n    raf(() => {\n        const input = element.nativeElement;\n        const hasValue = input.value != null && input.value.toString().length > 0;\n        const classes = getClasses(input);\n        setClasses(input, classes);\n        const item = input.closest('ion-item');\n        if (item) {\n            if (hasValue) {\n                setClasses(item, [...classes, 'item-has-value']);\n            }\n            else {\n                setClasses(item, classes);\n            }\n        }\n    });\n};\nconst getClasses = (element) => {\n    const classList = element.classList;\n    const classes = [];\n    for (let i = 0; i < classList.length; i++) {\n        const item = classList.item(i);\n        if (item !== null && startsWith(item, 'ng-')) {\n            classes.push(`ion-${item.substring(3)}`);\n        }\n    }\n    return classes;\n};\nconst setClasses = (element, classes) => {\n    const classList = element.classList;\n    classList.remove('ion-valid', 'ion-invalid', 'ion-touched', 'ion-untouched', 'ion-dirty', 'ion-pristine');\n    classList.add(...classes);\n};\nconst startsWith = (input, search) => {\n    return input.substring(0, search.length) === search;\n};\n\n/**\n * Provides a way to customize when activated routes get reused.\n */\nclass IonicRouteStrategy {\n    /**\n     * Whether the given route should detach for later reuse.\n     */\n    shouldDetach(_route) {\n        return false;\n    }\n    /**\n     * Returns `false`, meaning the route (and its subtree) is never reattached\n     */\n    shouldAttach(_route) {\n        return false;\n    }\n    /**\n     * A no-op; the route is never stored since this strategy never detaches routes for later re-use.\n     */\n    store(_route, _detachedTree) {\n        return;\n    }\n    /**\n     * Returns `null` because this strategy does not store routes for later re-use.\n     */\n    retrieve(_route) {\n        return null;\n    }\n    /**\n     * Determines if a route should be reused.\n     * This strategy returns `true` when the future route config and\n     * current route config are identical and all route parameters are identical.\n     */\n    shouldReuseRoute(future, curr) {\n        if (future.routeConfig !== curr.routeConfig) {\n            return false;\n        }\n        // checking router params\n        const futureParams = future.params;\n        const currentParams = curr.params;\n        const keysA = Object.keys(futureParams);\n        const keysB = Object.keys(currentParams);\n        if (keysA.length !== keysB.length) {\n            return false;\n        }\n        // Test for A's keys different from B.\n        for (const key of keysA) {\n            if (currentParams[key] !== futureParams[key]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n// TODO(FW-2827): types\nclass OverlayBaseController {\n    ctrl;\n    constructor(ctrl) {\n        this.ctrl = ctrl;\n    }\n    /**\n     * Creates a new overlay\n     */\n    create(opts) {\n        return this.ctrl.create((opts || {}));\n    }\n    /**\n     * When `id` is not provided, it dismisses the top overlay.\n     */\n    dismiss(data, role, id) {\n        return this.ctrl.dismiss(data, role, id);\n    }\n    /**\n     * Returns the top overlay.\n     */\n    getTop() {\n        return this.ctrl.getTop();\n    }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngularDelegate, Config, ConfigToken, DomController, IonBackButton, IonModal, IonNav, IonPopover, IonRouterOutlet, IonTabs, IonicRouteStrategy, MenuController, NavController, NavParams, OverlayBaseController, Platform, ProxyCmp, RouterLinkDelegateDirective, RouterLinkWithHrefDelegateDirective, ValueAccessor, bindLifecycleEvents, provideComponentInputBinding, raf, setIonicClasses };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}